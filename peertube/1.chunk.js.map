{"version":3,"sources":["webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"names":["Events","on","event","listener","super","emit","args","settings","fetchRequests","Map","failedSegments","debug","fetch","download","segment","downloadedPieces","this","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","requestUrl","headers","Headers","range","append","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","fetchAbort","AbortController","signal","fetchRequest","setupFetchEvents","fetchResponse","set","id","initialPriority","priority","updatePriority","request","get","Error","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","catch","error","segmentFailure","dataReader","body","getReader","contentLengthStr","contentLength","Number","parseFloat","dataBytes","Uint8Array","nextChunkPos","Array","isArray","status","pieceBytes","read","done","chunkBytes","value","length","err","url","segmentDownloadFinished","buffer","data","responseUrl","segmentValidator","httpFailedSegmentTimeout","candidates","push","performance","localTransport","segmentUrlBuilder","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","segmentData","offset","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","Object","streamSwarmId","keys","swarmData","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","from","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","config","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","isSupported","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","content","parser","playlist","manifest","playlists","variantPlaylist","found","updateSegments","res","getMasterSwarmId","asset","getAsset","responseURL","responseUri","response","loadContent","text","storeAsset","masterManifestUri","requestUri","processPlaylist","segmentLocation","getSegmentLocation","byteRangeString","result","next","arrayBuffer","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","duration","urlIndex","findIndex","playPosition","playheadPosition","currentSegmentPosition","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","playlistRequestUrl","segmentManager","isLoaded","stats","loaded","total","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","loadPlaylist","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","loadSegment","successSegment","off","console","warn","abortSegment","onAbort","xhr","onProgress","map","eventKey","engine","impl","getResponseHeader","getEngine","setPlayingSegment","setPlayingSegmentByCurrentTime","version","initHlsJsPlayer","player","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","addEventListener","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"mappings":"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","file":"1.chunk.js?v=9927","sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\n\r\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\r\nimport { Segment } from \"./loader-interface\";\r\nimport { SegmentValidatorCallback /*, XhrSetupCallback */, SegmentUrlBuilder } from \"./hybrid-loader\";\r\n\r\nclass FilteredEmitter extends STEEmitter<\r\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\r\n> { }\r\n\r\nexport class HttpMediaManager extends FilteredEmitter {\r\n    private fetchRequests = new Map<string, { fetchResponse: Response; fetchAbort: AbortController, segment: Segment, initialPriority: number, segmentUrl: string }>();\r\n    private failedSegments = new Map<string, number>();\r\n    private debug = Debug(\"p2pml:http-media-manager\");\r\n    private fetch: typeof fetch = (...args) => fetch(...args);\r\n\r\n    public constructor(\r\n        readonly settings: {\r\n            httpFailedSegmentTimeout: number;\r\n            httpUseRanges: boolean;\r\n            requiredSegmentsPriority: number;\r\n            segmentValidator?: SegmentValidatorCallback;\r\n            /* xhrSetup?: XhrSetupCallback; */\r\n            segmentUrlBuilder?: SegmentUrlBuilder;\r\n            localTransport?: typeof fetch;\r\n        }\r\n    ) {\r\n        super();\r\n\r\n        if (settings.localTransport) {\r\n            this.fetch = settings.localTransport;\r\n        }\r\n    }\r\n\r\n    public download = async (segment: Segment, downloadedPieces?: ArrayBuffer[]): Promise<void> => {\r\n        if (this.isDownloading(segment)) {\r\n            return;\r\n        }\r\n\r\n        this.cleanTimedOutFailedSegments();\r\n\r\n        this.emit(\"segment-start-load\", segment);\r\n\r\n        const segmentUrl = this.buildSegmentUrl(segment);\r\n\r\n        this.debug(\"http segment download\", segmentUrl);\r\n\r\n        segment.requestUrl = segmentUrl;\r\n\r\n        const headers = new Headers();\r\n\r\n        if (segment.range) {\r\n            headers.append('Range', segment.range);\r\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\r\n            let bytesDownloaded = 0;\r\n            for (const piece of downloadedPieces) {\r\n                bytesDownloaded += piece.byteLength;\r\n            }\r\n\r\n            headers.append(\"Range\", `bytes=${bytesDownloaded}-`);\r\n\r\n            this.debug(\"continue download from\", bytesDownloaded);\r\n        } else {\r\n            downloadedPieces = undefined;\r\n        }\r\n\r\n        const fetchAbort = new AbortController();\r\n        const signal = fetchAbort.signal;\r\n\r\n        const fetchRequest = this.fetch(segmentUrl, { headers, signal });\r\n\r\n        void this.setupFetchEvents(fetchRequest, segment, downloadedPieces);\r\n\r\n        /* if (this.settings.xhrSetup) {\r\n            this.settings.xhrSetup(xhr, segmentUrl);\r\n        } */\r\n\r\n        const fetchResponse = await fetchRequest;\r\n\r\n        this.fetchRequests.set(segment.id, { fetchResponse, fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\r\n    };\r\n\r\n    public updatePriority = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (!request) {\r\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\r\n        }\r\n\r\n        // Segment is now in high priority\r\n        // If the segment URL changed, retry the request with the new URL\r\n        if (\r\n            segment.priority <= this.settings.requiredSegmentsPriority &&\r\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\r\n            request.segmentUrl !== this.buildSegmentUrl(segment)\r\n        ) {\r\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\r\n            this.abort(segment)\r\n            void this.download(segment)\r\n        }\r\n\r\n    }\r\n\r\n    public abort = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (request) {\r\n            request.fetchAbort.abort();\r\n            this.fetchRequests.delete(segment.id);\r\n            this.debug(\"http segment abort\", segment.id);\r\n        }\r\n    };\r\n\r\n    public isDownloading = (segment: Segment): boolean => {\r\n        return this.fetchRequests.has(segment.id);\r\n    };\r\n\r\n    public isFailed = (segment: Segment): boolean => {\r\n        const time = this.failedSegments.get(segment.id);\r\n        return time !== undefined && time > this.now();\r\n    };\r\n\r\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\r\n        return this.fetchRequests;\r\n    };\r\n\r\n    public getActiveDownloadsCount = (): number => {\r\n        return this.fetchRequests.size;\r\n    };\r\n\r\n    public destroy = (): void => {\r\n        this.fetchRequests.forEach((request) => request.fetchAbort.abort());\r\n        this.fetchRequests.clear();\r\n    };\r\n\r\n    private setupFetchEvents = async (fetch: Promise<Response>, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\r\n        const fetchResponse = await fetch.catch((error) => {\r\n            this.segmentFailure(segment, error, \"url_not_retrieved\");\r\n        }) as Response & { body: ReadableStream };\r\n\r\n        const dataReader = fetchResponse.body.getReader();\r\n\r\n        const contentLengthStr = fetchResponse.headers.get(\"Content-Length\") as string;\r\n\r\n        const contentLength = Number.parseFloat(contentLengthStr);\r\n\r\n        const dataBytes: Uint8Array = new Uint8Array(contentLength);\r\n\r\n        let done = false;\r\n        let nextChunkPos = 0;\r\n\r\n        if (Array.isArray(downloadedPieces) && fetchResponse.status === 206) {\r\n            for (const piece of downloadedPieces) {\r\n                const pieceBytes = new Uint8Array(piece);\r\n\r\n                dataBytes.set(pieceBytes, nextChunkPos);\r\n\r\n                nextChunkPos = piece.byteLength;\r\n            }\r\n        }\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const read = await dataReader.read();\r\n\r\n            if (read.done) {\r\n                break;\r\n            }\r\n\r\n            const chunkBytes = read.value;\r\n\r\n            dataBytes.set(chunkBytes, nextChunkPos);\r\n\r\n            nextChunkPos += chunkBytes.length;\r\n\r\n            /** Events emitters */\r\n\r\n            this.emit(\"bytes-downloaded\", segment, chunkBytes.length);\r\n\r\n            if (contentLength) {\r\n                this.emit(\"segment-size\", segment, contentLength);\r\n            }\r\n        }\r\n\r\n        if (fetchResponse.status < 200 || fetchResponse.status >= 300) {\r\n            const err = Error(`Segment failure with HTTP code ${fetchResponse.status}`);\r\n            this.segmentFailure(segment, err, fetchResponse.url);\r\n            return;\r\n        }\r\n\r\n        await this.segmentDownloadFinished(segment, dataBytes.buffer, fetchResponse);\r\n    };\r\n\r\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, fetchResponse: Response) => {\r\n        segment.responseUrl = fetchResponse.url;\r\n\r\n        if (this.settings.segmentValidator) {\r\n            try {\r\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\r\n            } catch (error) {\r\n                this.debug(\"segment validator failed\", error);\r\n                this.segmentFailure(segment, error, fetchResponse.url);\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.emit(\"segment-loaded\", segment, data);\r\n    };\r\n\r\n    private segmentFailure = (segment: Segment, error: Error, responseUrl: string) => {\r\n        segment.responseUrl = responseUrl;\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\r\n        this.emit(\"segment-error\", segment, error);\r\n    };\r\n\r\n    private cleanTimedOutFailedSegments = () => {\r\n        const now = this.now();\r\n        const candidates: string[] = [];\r\n\r\n        this.failedSegments.forEach((time, id) => {\r\n            if (time < now) {\r\n                candidates.push(id);\r\n            }\r\n        });\r\n\r\n        candidates.forEach((id) => this.failedSegments.delete(id));\r\n    };\r\n\r\n    private buildSegmentUrl (segment: Segment) {\r\n        if (this.settings.segmentUrlBuilder) {\r\n            return this.settings.segmentUrlBuilder(segment);\r\n        }\r\n\r\n        return segment.url;\r\n    }\r\n\r\n    private now = () => performance.now();\r\n}\r\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\nimport { EventEmitter } from \"events\";\r\nimport Peer from \"simple-peer\";\r\n\r\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\r\nimport { HttpMediaManager } from \"./http-media-manager\";\r\nimport { P2PMediaManager } from \"./p2p-media-manager\";\r\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\r\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\r\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\r\n/*\r\nconst defaultSettings: HybridLoaderSettings = {\r\n    cachedSegmentExpiration: 5 * 60 * 1000,\r\n    cachedSegmentsCount: 30,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 1,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.1,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 10000,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 4000,\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 3,\r\n    p2pDownloadMaxPriority: 20,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};*/\r\n\r\n\r\nconst defaultSettings: HybridLoaderSettings & { localTransport?: typeof fetch } = {\r\n    cachedSegmentExpiration: 10 * 60 * 1000,\r\n    cachedSegmentsCount: 1000,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 3,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.06,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 1500,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 20,\r\n    p2pDownloadMaxPriority: 50,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};\r\n\r\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\r\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\r\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\r\n    private readonly httpManager: HttpMediaManager;\r\n    private readonly p2pManager: P2PMediaManager;\r\n    private segmentsStorage: SegmentsStorage;\r\n    private segmentsQueue: Segment[] = [];\r\n    private readonly bandwidthApproximator = new BandwidthApproximator();\r\n    private readonly settings: HybridLoaderSettings & { localTransport?: typeof fetch };\r\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\r\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n    private masterSwarmId?: string;\r\n\r\n    public static isSupported = (): boolean => {\r\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\r\n    };\r\n\r\n    public constructor(settings: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }> = {}) {\r\n        super();\r\n\r\n        this.settings = { ...defaultSettings, ...settings };\r\n\r\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\r\n\r\n        if (typeof bufferedSegmentsCount === \"number\") {\r\n            if (settings.p2pDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n\r\n            if (settings.httpDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n        }\r\n\r\n        this.segmentsStorage =\r\n            this.settings.segmentsStorage === undefined\r\n                ? new SegmentsMemoryStorage(this.settings)\r\n                : this.settings.segmentsStorage;\r\n\r\n        this.debug(\"loader settings\", this.settings);\r\n\r\n        this.httpManager = this.createHttpManager();\r\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\r\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\r\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\r\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\r\n        });\r\n\r\n        this.p2pManager = this.createP2PManager();\r\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\r\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\r\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.p2pManager.on(\"peer-data-updated\", async () => {\r\n            if (this.masterSwarmId === undefined) {\r\n                return;\r\n            }\r\n\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        });\r\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\r\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\r\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\r\n    }\r\n\r\n    private createHttpManager = () => {\r\n        return new HttpMediaManager(this.settings);\r\n    };\r\n\r\n    private createP2PManager = () => {\r\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\r\n    };\r\n\r\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            // Do once on first call\r\n            this.httpRandomDownloadInterval = setInterval(\r\n                this.downloadRandomSegmentOverHttp,\r\n                this.settings.httpDownloadProbabilityInterval\r\n            );\r\n\r\n            if (\r\n                this.settings.httpDownloadInitialTimeout > 0 &&\r\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\r\n            ) {\r\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\r\n                this.debugSegments(\r\n                    \"enable initial HTTP download timeout\",\r\n                    this.settings.httpDownloadInitialTimeout,\r\n                    \"per segment\",\r\n                    this.settings.httpDownloadInitialTimeoutPerSegment\r\n                );\r\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\r\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            this.masterSwarmId = segments[0].masterSwarmId;\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\r\n        }\r\n\r\n        this.debug(\"load segments\");\r\n\r\n        let updateSegmentsMap = false;\r\n\r\n        // stop all http requests and p2p downloads for segments that are not in the new load\r\n        for (const segment of this.segmentsQueue) {\r\n            if (!segments.find((f) => f.url === segment.url)) {\r\n                this.debug(\"remove segment\", segment.url);\r\n                if (this.httpManager.isDownloading(segment)) {\r\n                    updateSegmentsMap = true;\r\n                    this.httpManager.abort(segment);\r\n                } else {\r\n                    this.p2pManager.abort(segment);\r\n                }\r\n                this.emit(Events.SegmentAbort, segment);\r\n            }\r\n        }\r\n\r\n        if (this.debug.enabled) {\r\n            for (const segment of segments) {\r\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\r\n                    this.debug(\"add segment\", segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.segmentsQueue = segments;\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\r\n\r\n        if (await this.cleanSegmentsStorage()) {\r\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            updateSegmentsMap = true;\r\n        }\r\n\r\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\r\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\r\n    };\r\n\r\n    public getSettings = (): HybridLoaderSettings => {\r\n        return this.settings;\r\n    };\r\n\r\n    public getDetails = (): { peerId: string } => {\r\n        return {\r\n            peerId: this.p2pManager.getPeerId(),\r\n        };\r\n    };\r\n\r\n    public getBandwidthEstimate = (): number => {\r\n        return this.bandwidthApproximator.getBandwidth(this.now());\r\n    };\r\n\r\n    public destroy = async (): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval !== undefined) {\r\n            clearInterval(this.httpRandomDownloadInterval);\r\n            this.httpRandomDownloadInterval = undefined;\r\n        }\r\n\r\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n        this.segmentsQueue = [];\r\n        this.httpManager.destroy();\r\n        this.p2pManager.destroy();\r\n        this.masterSwarmId = undefined;\r\n        await this.segmentsStorage.destroy();\r\n    };\r\n\r\n    private processInitialSegmentTimeout = async () => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            return; // Instance destroyed\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            // Set one more timeout for a next segment\r\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\r\n        }\r\n    };\r\n\r\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        this.debugSegments(\r\n            \"process segments queue. priority\",\r\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\r\n        );\r\n\r\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        let updateSegmentsMap = false;\r\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\r\n\r\n        let httpAllowed = true;\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            let firstNotDownloadePriority: number | undefined;\r\n\r\n            for (const segment of this.segmentsQueue) {\r\n                if (!storageSegments.has(segment.id)) {\r\n                    firstNotDownloadePriority = segment.priority;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\r\n            httpAllowed =\r\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\r\n                (firstNotDownloadePriority !== undefined &&\r\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\r\n                    firstNotDownloadePriority <= 0);\r\n\r\n            if (httpAllowed) {\r\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\r\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\r\n            const segment = this.segmentsQueue[index];\r\n\r\n            if (storageSegments.has(segment.id)) {\r\n                continue;\r\n            }\r\n\r\n            // Segment priority changed, notify http manager\r\n            if (this.httpManager.isDownloading(segment)) {\r\n                this.httpManager.updatePriority(segment);\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                segment.priority <= this.settings.requiredSegmentsPriority &&\r\n                httpAllowed &&\r\n                !this.httpManager.isFailed(segment)\r\n            ) {\r\n                // Download required segments over HTTP\r\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\r\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.httpManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\r\n                    // Abort P2P download of the required segment if any and force HTTP download\r\n                    const downloadedPieces = this.p2pManager.abort(segment);\r\n                    void this.httpManager.download(segment, downloadedPieces);\r\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\r\n                    updateSegmentsMap = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (this.p2pManager.isDownloading(segment)) {\r\n                continue;\r\n            }\r\n\r\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\r\n                // Download required segments over P2P\r\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\r\n\r\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\r\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.p2pManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\r\n                    if (this.p2pManager.download(segment)) {\r\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\r\n                segment.priority <= this.settings.p2pDownloadMaxPriority\r\n            ) {\r\n                if (this.p2pManager.download(segment)) {\r\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        return updateSegmentsMap;\r\n    };\r\n\r\n    private downloadRandomSegmentOverHttp = async () => {\r\n        if (\r\n            this.masterSwarmId === undefined ||\r\n            this.httpRandomDownloadInterval === undefined ||\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\r\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\r\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\r\n            this.settings.consumeOnly\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\r\n\r\n        const pendingQueue = this.segmentsQueue.filter(\r\n            (s) =>\r\n                !this.p2pManager.isDownloading(s) &&\r\n                !this.httpManager.isDownloading(s) &&\r\n                !segmentsMap.has(s.id) &&\r\n                !this.httpManager.isFailed(s) &&\r\n                s.priority <= this.settings.httpDownloadMaxPriority &&\r\n                !storageSegments.has(s.id)\r\n        );\r\n\r\n        if (pendingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\r\n            return;\r\n        }\r\n\r\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\r\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\r\n        void this.httpManager.download(segment);\r\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n    };\r\n\r\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n        this.emit(Events.SegmentStartLoad, method, segment);\r\n    };\r\n\r\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.bandwidthApproximator.addBytes(bytes, this.now());\r\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\r\n\r\n    };\r\n\r\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\r\n    };\r\n\r\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\r\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        segment.data = data;\r\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\r\n\r\n        await this.segmentsStorage.storeSegment(segment);\r\n        this.emit(Events.SegmentLoaded, segment, peerId);\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n        this.processSegmentsQueue(storageSegments);\r\n        if (!this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\r\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\r\n        this.emit(Events.SegmentError, segment, details, peerId);\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n    };\r\n\r\n    private onSegmentSize = async (segment: Segment, size: number) => {\r\n        this.debugSegments(\"segment size\", segment.id, size);\r\n        this.emit(Events.SegmentSize, segment, size);\r\n    };\r\n\r\n    private getStreamSwarmId = (segment: Segment) => {\r\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\r\n    };\r\n\r\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\r\n\r\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\r\n            const streamSwarmId = this.getStreamSwarmId(segment);\r\n            const segmentId = segment.sequence;\r\n\r\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\r\n            if (segmentsIdsAndStatuses === undefined) {\r\n                segmentsIdsAndStatuses = [\"\", []];\r\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\r\n            }\r\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\r\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\r\n            segmentsStatuses.push(status);\r\n        };\r\n\r\n        for (const storageSegment of storageSegments.values()) {\r\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\r\n        }\r\n\r\n        for (const download of this.httpManager.getActiveDownloads().values()) {\r\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\r\n        }\r\n\r\n        return segmentsMap;\r\n    };\r\n\r\n    private onPeerConnect = async (peer: { id: string }) => {\r\n        this.emit(Events.PeerConnect, peer);\r\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\r\n            this.p2pManager.sendSegmentsMap(\r\n                peer.id,\r\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\r\n            );\r\n        }\r\n    };\r\n\r\n    private onPeerClose = (peerId: string) => {\r\n        this.emit(Events.PeerClose, peerId);\r\n    };\r\n\r\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\r\n        if (\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\r\n            data.incomplete !== undefined &&\r\n            data.incomplete <= 1\r\n        ) {\r\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\r\n\r\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n            if (this.masterSwarmId !== undefined) {\r\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\r\n        if (this.masterSwarmId === undefined) {\r\n            return false;\r\n        }\r\n\r\n        return this.segmentsStorage.clean(\r\n            this.masterSwarmId,\r\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\r\n        );\r\n    };\r\n\r\n    private now = () => {\r\n        return performance.now();\r\n    };\r\n}\r\n\r\nexport interface SegmentsStorage {\r\n    storeSegment: (segment: Segment) => Promise<void>;\r\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\r\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\r\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\r\n    destroy: () => Promise<void>;\r\n}\r\n\r\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\r\n/* export type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void; */\r\nexport type SegmentUrlBuilder = (segment: Segment) => string;\r\n\r\nexport type HybridLoaderSettings = {\r\n    /**\r\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\r\n     */\r\n    cachedSegmentExpiration: number;\r\n\r\n    /**\r\n     * Max number of segments that can be stored in the cache.\r\n     */\r\n    cachedSegmentsCount: number;\r\n\r\n    /**\r\n     * Enable/Disable peers interaction.\r\n     */\r\n    useP2P: boolean;\r\n\r\n    /**\r\n     * The peer will not upload segments data to the P2P network but still download from others.\r\n     */\r\n    consumeOnly: boolean;\r\n\r\n    /**\r\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\r\n     */\r\n    requiredSegmentsPriority: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from HTTP source.\r\n     */\r\n    simultaneousHttpDownloads: number;\r\n\r\n    /**\r\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\r\n     */\r\n    httpDownloadProbability: number;\r\n\r\n    /**\r\n     * Interval of the httpDownloadProbability check (in milliseconds).\r\n     */\r\n    httpDownloadProbabilityInterval: number;\r\n\r\n    /**\r\n     * Don't download segments over HTTP randomly when there is no peers.\r\n     */\r\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\r\n\r\n    /**\r\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\r\n     */\r\n    httpFailedSegmentTimeout: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over HTTP.\r\n     */\r\n    httpDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Try to download initial segments over P2P if the value is > 0.\r\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\r\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\r\n     */\r\n    httpDownloadInitialTimeout: number;\r\n\r\n    /**\r\n     * Use HTTP ranges requests where it is possible.\r\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\r\n     */\r\n    httpUseRanges: boolean;\r\n\r\n    /**\r\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\r\n     * this parameter sets additional timeout for a single sequential segment download\r\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\r\n     */\r\n    httpDownloadInitialTimeoutPerSegment: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from peers.\r\n     */\r\n    simultaneousP2PDownloads: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over P2P.\r\n     */\r\n    p2pDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\r\n     */\r\n    p2pSegmentDownloadTimeout: number;\r\n\r\n    /**\r\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\r\n     */\r\n    webRtcMaxMessageSize: number;\r\n\r\n    /**\r\n     * Torrent trackers (announcers) to use.\r\n     */\r\n    trackerAnnounce: string[];\r\n\r\n    /**\r\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\r\n     */\r\n    peerRequestsPerAnnounce: number;\r\n\r\n    /**\r\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\r\n     */\r\n    rtcConfig: RTCConfiguration;\r\n\r\n    /**\r\n     * Segment validation callback - validates the data after it has been downloaded.\r\n     */\r\n    segmentValidator?: SegmentValidatorCallback;\r\n\r\n    /**\r\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\r\n     */\r\n    /* xhrSetup?: unknown; */\r\n\r\n    /**\r\n     * Allow to modify the segment URL before HTTP request.\r\n     */\r\n    segmentUrlBuilder?: SegmentUrlBuilder;\r\n\r\n    /**\r\n     * A storage for the downloaded segments.\r\n     * By default the segments are stored in JavaScript memory.\r\n     */\r\n    segmentsStorage?: SegmentsStorage;\r\n};\r\n","import { LoaderContext } from \"hls.js\"\r\n\r\nexport type ByteRange = { length: number; offset: number } | undefined;\r\n\r\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\r\n  return context.rangeEnd && context.rangeStart !== undefined\r\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\r\n      : undefined;\r\n}\r\n\r\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\r\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\r\n}\r\n\r\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\r\n  if (byteRange === undefined) {\r\n      return undefined;\r\n  }\r\n\r\n  const end = byteRange.offset + byteRange.length - 1;\r\n\r\n  return `bytes=${byteRange.offset}-${end}`;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Events, Segment, LoaderInterface } from \"../../p2p-media-loader-core/lib\";\r\nimport { Manifest, Parser } from \"m3u8-parser\";\r\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\r\nimport { AssetsStorage, HlsJsEngineSettings } from \"./engine\";\r\n\r\nconst defaultSettings: SegmentManagerSettings = {\r\n    forwardSegmentCount: 20,\r\n    swarmId: undefined,\r\n    assetsStorage: undefined,\r\n};\r\n\r\nexport class SegmentManager {\r\n    public readonly loader: LoaderInterface;\r\n    private masterPlaylist: Playlist | null = null;\r\n    private readonly variantPlaylists = new Map<string, Playlist>();\r\n    private segmentRequest: SegmentRequest | null = null;\r\n    private readonly fetch: typeof fetch = (...args) => fetch(...args);\r\n    private playQueue: {\r\n        segmentSequence: number;\r\n        segmentUrl: string;\r\n        segmentByteRange: ByteRange;\r\n        playPosition?: {\r\n            start: number;\r\n            duration: number;\r\n        };\r\n    }[] = [];\r\n    private readonly settings: SegmentManagerSettings;\r\n\r\n    public constructor(loader: LoaderInterface, settings: Partial<HlsJsEngineSettings> = {}) {\r\n        this.settings = { ...defaultSettings, ...settings.segments };\r\n\r\n        this.loader = loader;\r\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\r\n        this.loader.on(Events.SegmentError, this.onSegmentError);\r\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\r\n\r\n        if (settings.loader && settings.loader.localTransport) {\r\n            this.fetch = settings.loader.localTransport;\r\n        }\r\n    }\r\n\r\n    public getSettings(): SegmentManagerSettings {\r\n        return this.settings;\r\n    }\r\n\r\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\r\n        const parser = new Parser();\r\n        parser.push(content);\r\n        parser.end();\r\n\r\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\r\n\r\n        if (playlist.manifest.playlists) {\r\n            this.masterPlaylist = playlist;\r\n\r\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\r\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\r\n                if (!found) {\r\n                    this.variantPlaylists.delete(key);\r\n                } else {\r\n                    variantPlaylist.streamSwarmId = streamSwarmId;\r\n                    variantPlaylist.streamId = \"V\" + index.toString();\r\n                }\r\n            }\r\n        } else {\r\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\r\n\r\n            if (found || this.masterPlaylist === null) {\r\n                // do not add audio and subtitles to variants\r\n                playlist.streamSwarmId = streamSwarmId;\r\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\r\n                this.variantPlaylists.set(requestUrl, playlist);\r\n                this.updateSegments();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\r\n        const assetsStorage = this.settings.assetsStorage;\r\n        let res: { response: string; responseURL: string } | undefined;\r\n\r\n        if (assetsStorage !== undefined) {\r\n            let masterSwarmId: string | undefined;\r\n            masterSwarmId = this.getMasterSwarmId();\r\n            if (masterSwarmId === undefined) {\r\n                masterSwarmId = url.split(\"?\")[0];\r\n            }\r\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\r\n\r\n            if (asset !== undefined) {\r\n                res = {\r\n                    responseURL: asset.responseUri,\r\n                    response: asset.data as string,\r\n                };\r\n            } else {\r\n                const fetch = await this.loadContent(url);\r\n\r\n                res = {\r\n                    responseURL: fetch.url,\r\n                    response: await fetch.text(),\r\n                };\r\n\r\n                void assetsStorage.storeAsset({\r\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\r\n                    masterSwarmId: masterSwarmId,\r\n                    requestUri: url,\r\n                    responseUri: res.responseURL,\r\n                    data: await res.response,\r\n                });\r\n            }\r\n        } else {\r\n            const fetch = await this.loadContent(url);\r\n\r\n            res = {\r\n                responseURL: fetch.url,\r\n                response: await fetch.text(),\r\n            };\r\n        }\r\n\r\n        this.processPlaylist(url, res.response, res.responseURL);\r\n        return res;\r\n    }\r\n\r\n    \r\n\r\n    public async loadSegment(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\r\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\r\n        const byteRangeString = byteRangeToString(byteRange);\r\n\r\n        if (!segmentLocation) {\r\n            let content: ArrayBuffer | undefined;\r\n\r\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\r\n            const assetsStorage = this.settings.assetsStorage;\r\n            if (assetsStorage !== undefined) {\r\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\r\n\r\n                let masterSwarmId: string | undefined;\r\n                masterSwarmId = this.getMasterSwarmId();\r\n\r\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\r\n                    }\r\n                }\r\n\r\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterManifestUri = result.value.requestUrl;\r\n                    }\r\n                }\r\n\r\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\r\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\r\n                    if (asset !== undefined) {\r\n                        content = asset.data as ArrayBuffer;\r\n                    } else {\r\n                        const fetch = await this.loadContent(url, byteRangeString);\r\n                        content = await fetch.arrayBuffer();\r\n                        void assetsStorage.storeAsset({\r\n                            masterManifestUri: masterManifestUri,\r\n                            masterSwarmId: masterSwarmId,\r\n                            requestUri: url,\r\n                            requestRange: byteRangeString,\r\n                            responseUri: fetch.url,\r\n                            data: content,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (content === undefined) {\r\n                const fetch = await this.loadContent(url, byteRangeString);\r\n                content = await fetch.arrayBuffer();\r\n            }\r\n\r\n            return { content, downloadBandwidth: 0 };\r\n        }\r\n\r\n        const segmentSequence =\r\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\r\n            segmentLocation.segmentIndex;\r\n\r\n        if (this.playQueue.length > 0) {\r\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\r\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\r\n                // Reset play queue in case of segment loading out of sequence\r\n                this.playQueue = [];\r\n            }\r\n        }\r\n\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\r\n        }\r\n\r\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\r\n            (resolve, reject) => {\r\n\r\n                this.segmentRequest = new SegmentRequest(\r\n                    url,\r\n                    byteRange,\r\n                    segmentSequence,\r\n                    segmentLocation.playlist.requestUrl,\r\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\r\n                        resolve({ content, downloadBandwidth }),\r\n                    (error) => reject(error)\r\n                );\r\n                \r\n            }\r\n        );\r\n\r\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\r\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\r\n\r\n        return promise;\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        const urlIndex = this.playQueue.findIndex(\r\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\r\n        );\r\n\r\n        if (urlIndex >= 0) {\r\n            this.playQueue = this.playQueue.slice(urlIndex);\r\n            this.playQueue[0].playPosition = { start, duration };\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\r\n            return;\r\n        }\r\n\r\n        const currentSegmentPosition = this.playQueue[0].playPosition;\r\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\r\n\r\n        if (segmentEndTime - playheadPosition < 0.2) {\r\n            // means that current segment is (almost) finished playing\r\n            // remove it from queue\r\n\r\n            this.playQueue = this.playQueue.slice(1);\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public abortSegment(url: string, byteRange: ByteRange): void {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === url &&\r\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\r\n        ) {\r\n            this.segmentRequest.onSuccess(undefined, 0);\r\n            this.segmentRequest = null;\r\n        }\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\r\n            this.segmentRequest = null;\r\n        }\r\n\r\n        this.masterPlaylist = null;\r\n        this.variantPlaylists.clear();\r\n        this.playQueue = [];\r\n\r\n        if (this.settings.assetsStorage !== undefined) {\r\n            await this.settings.assetsStorage.destroy();\r\n        }\r\n\r\n        await this.loader.destroy();\r\n    }\r\n\r\n    private updateSegments(): void {\r\n        if (!this.segmentRequest) {\r\n            return;\r\n        }\r\n\r\n        const segmentLocation = this.getSegmentLocation(\r\n            this.segmentRequest.segmentUrl,\r\n            this.segmentRequest.segmentByteRange\r\n        );\r\n        if (segmentLocation) {\r\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\r\n        }\r\n    }\r\n\r\n    private onSegmentLoaded = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentError = (segment: Segment, error: unknown) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(error);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentAbort = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private getSegmentLocation(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\r\n        for (const playlist of this.variantPlaylists.values()) {\r\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\r\n            if (segmentIndex >= 0) {\r\n                return { playlist: playlist, segmentIndex: segmentIndex };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\r\n        const segments: Segment[] = [];\r\n        const playlistSegments = playlist.manifest.segments;\r\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\r\n        let loadSegmentId: string | null = null;\r\n\r\n        let priority = Math.max(0, this.playQueue.length - 1);\r\n\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        for (\r\n            let i = segmentIndex;\r\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\r\n            ++i\r\n        ) {\r\n            const segment = playlist.manifest.segments[i];\r\n\r\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\r\n            const byteRange: ByteRange = segment.byterange;\r\n            const id = this.getSegmentId(playlist, initialSequence + i);\r\n\r\n            segments.push({\r\n                id: id,\r\n                url: url,\r\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\r\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\r\n                streamId: playlist.streamId,\r\n                sequence: (initialSequence + i).toString(),\r\n                range: byteRangeToString(byteRange),\r\n                priority: priority++,\r\n            });\r\n            if (requestFirstSegment && !loadSegmentId) {\r\n                loadSegmentId = id;\r\n            }\r\n        }\r\n\r\n        this.loader.load(segments, playlist.streamSwarmId);\r\n\r\n        if (loadSegmentId) {\r\n            const segment = await this.loader.getSegment(loadSegmentId);\r\n\r\n\r\n\r\n            if (segment) {\r\n                // Segment already loaded by loader\r\n                this.onSegmentLoaded(segment);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\r\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\r\n    }\r\n\r\n    private getMasterSwarmId() {\r\n        const settingsSwarmId =\r\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\r\n        if (settingsSwarmId !== undefined) {\r\n            return settingsSwarmId;\r\n        }\r\n\r\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\r\n    }\r\n\r\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\r\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\r\n                const url = new URL(\r\n                    this.masterPlaylist.manifest.playlists[i].uri,\r\n                    this.masterPlaylist.responseUrl\r\n                ).toString();\r\n                if (url === playlistUrl) {\r\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\r\n            found: false,\r\n            index: -1,\r\n        };\r\n    }\r\n\r\n    private async loadContent(\r\n        url: string,\r\n        range?: string\r\n    ): Promise<Response> {\r\n        const headers = new Headers();\r\n\r\n        if (range) {\r\n            headers.append('Range', range);\r\n        }\r\n\r\n        return this.fetch(url, { headers });\r\n    }\r\n}\r\n\r\nclass Playlist {\r\n    public streamSwarmId = \"\";\r\n    public streamId?: string;\r\n\r\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\r\n\r\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\r\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\r\n            const segment = this.manifest.segments[i];\r\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\r\n\r\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\r\n        return new URL(segmentUrl, this.responseUrl).toString();\r\n    }\r\n}\r\n\r\nclass SegmentRequest {\r\n    public constructor(\r\n        readonly segmentUrl: string,\r\n        readonly segmentByteRange: ByteRange,\r\n        readonly segmentSequence: number,\r\n        readonly playlistRequestUrl: string,\r\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\r\n        readonly onError: (error: unknown) => void\r\n    ) {}\r\n}\r\n\r\nexport interface SegmentManagerSettings {\r\n    /**\r\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\r\n     */\r\n    forwardSegmentCount: number;\r\n\r\n    /**\r\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\r\n     * query parameters is used as the swarm ID if the parameter is not specified)\r\n     */\r\n    swarmId?: string;\r\n\r\n    /**\r\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\r\n     */\r\n    assetsStorage?: AssetsStorage;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { SegmentManager } from \"./segment-manager\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\r\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\r\n\r\nexport class HlsJsLoader {\r\n    private isLoaded = false;\r\n    private segmentManager: SegmentManager;\r\n    public stats: LoaderStats = {\r\n        loaded: 0,\r\n        total: 0,\r\n        aborted: false,\r\n        retry: 0,\r\n        chunkCount: 0,\r\n        bwEstimate: 0,\r\n        loading: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n        parsing: {\r\n            start: 0,\r\n            end: 0,\r\n        },\r\n        buffering: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n    };\r\n\r\n    public constructor(segmentManager: SegmentManager) {\r\n        this.segmentManager = segmentManager;\r\n    }\r\n\r\n    public async load(\r\n        context: LoaderContext,\r\n        _config: LoaderConfiguration,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): Promise<void> {\r\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n        if (((context as unknown) as { type: unknown }).type) {\r\n            try {\r\n                const result = await this.segmentManager.loadPlaylist(context.url);\r\n                this.isLoaded = true;\r\n                this.successPlaylist(result, context, callbacks);\r\n            } catch (e : any) {\r\n                this.error(e, context, callbacks);\r\n            }\r\n        } else if (((context as unknown) as { frag: unknown }).frag) {\r\n            const { loader } = this.segmentManager;\r\n            const byteRange = getByteRange(context)\r\n\r\n            const isSegment = (segment: Segment) => {\r\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\r\n            }\r\n\r\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\r\n            let updateStart: NodeJS.Timeout | undefined = setInterval(() => {\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n            }, 200)\r\n\r\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.total = size\r\n            };\r\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\r\n\r\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.loaded += bytes\r\n            };\r\n\r\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\r\n\r\n                clearInterval(updateStart)\r\n                updateStart = undefined\r\n\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            };\r\n\r\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\r\n\r\n\r\n            try {\r\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\r\n                const { content } = result;\r\n                if (content) {\r\n                    this.isLoaded = true;\r\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\r\n                }\r\n\r\n            } catch (e : any) {\r\n                setTimeout(() => this.error(e, context, callbacks), 0);\r\n            } finally {\r\n\r\n                clearInterval(updateStart)\r\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\r\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\r\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            }\r\n\r\n\r\n\r\n\r\n        } else {\r\n            console.warn(\"Unknown load request\", context);\r\n        }\r\n    }\r\n\r\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\r\n        if (this.isLoaded) return;\r\n\r\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\r\n        this.stats.aborted = true;\r\n\r\n        const onAbort = callbacks?.onAbort;\r\n        if (onAbort) {\r\n            onAbort(this.stats, context, undefined);\r\n        }\r\n    }\r\n\r\n    private successPlaylist(\r\n        xhr: { response: string; responseURL: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = xhr.response.length;\r\n        this.stats.total = xhr.response.length;\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: xhr.responseURL,\r\n                data: xhr.response,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private successSegment(\r\n        content: ArrayBuffer,\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = content.byteLength;\r\n        this.stats.total = content.byteLength;\r\n\r\n        if (callbacks.onProgress) {\r\n            callbacks.onProgress(this.stats, context, content, undefined);\r\n        }\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: context.url,\r\n                data: content,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private error(\r\n        error: { code: number; text: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        callbacks.onError(error, context, undefined);\r\n    }\r\n\r\n    private static updateStatsToStartLoading (stats: LoaderStats) {\r\n        const start = performance.now();\r\n        stats.loading.start = start;\r\n        stats.loading.first = start;\r\n    }\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\r\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\r\nimport { HlsJsLoader } from \"./hlsjs-loader\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { ByteRange } from \"./byte-range\"\r\n\r\nexport interface HlsJsEngineSettings {\r\n    loader: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }>;\r\n    segments: Partial<SegmentManagerSettings>;\r\n}\r\n\r\nexport class Engine extends EventEmitter {\r\n    public static isSupported(): boolean {\r\n        return HybridLoader.isSupported();\r\n    }\r\n\r\n    private readonly loader: LoaderInterface;\r\n    private readonly segmentManager: SegmentManager;\r\n\r\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\r\n        super();\r\n\r\n        this.loader = new HybridLoader(settings.loader);\r\n        this.segmentManager = new SegmentManager(this.loader, settings);\r\n\r\n        Object.keys(Events)\r\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\r\n            .forEach((event) => this.loader.on(event, (...args: unknown[]) => this.emit(event, ...args)));\r\n    }\r\n\r\n    public createLoaderClass(): new () => unknown {\r\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        return class {\r\n            private impl: HlsJsLoader;\r\n            private context?: LoaderContext;\r\n            private callbacks?: LoaderCallbacks<LoaderContext>;\r\n            public stats: LoaderStats;\r\n\r\n            constructor() {\r\n                this.impl = new HlsJsLoader(engine.segmentManager);\r\n                this.stats = this.impl.stats;\r\n            }\r\n\r\n            load = async (\r\n                context: LoaderContext,\r\n                config: LoaderConfiguration,\r\n                callbacks: LoaderCallbacks<LoaderContext>\r\n            ) => {\r\n                this.context = context;\r\n                this.callbacks = callbacks;\r\n                this.impl.load(context, config, callbacks);\r\n\r\n            };\r\n\r\n            abort = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context, this.callbacks);\r\n                }\r\n            };\r\n\r\n            destroy = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context);\r\n                }\r\n            };\r\n\r\n            getResponseHeader = () => undefined;\r\n\r\n            static getEngine = () => {\r\n                return engine;\r\n            };\r\n        };\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        await this.segmentManager.destroy();\r\n    }\r\n\r\n    public getSettings(): {\r\n        segments: SegmentManagerSettings;\r\n        loader: unknown;\r\n    } {\r\n        return {\r\n            segments: this.segmentManager.getSettings(),\r\n            loader: this.loader.getSettings(),\r\n        };\r\n    }\r\n\r\n    public getDetails(): unknown {\r\n        return {\r\n            loader: this.loader.getDetails(),\r\n        };\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\r\n    }\r\n\r\n}\r\n\r\nexport interface Asset {\r\n    masterSwarmId: string;\r\n    masterManifestUri: string;\r\n    requestUri: string;\r\n    requestRange?: string;\r\n    responseUri: string;\r\n    data: ArrayBuffer | string;\r\n}\r\n\r\nexport interface AssetsStorage {\r\n    storeAsset(asset: Asset): Promise<void>;\r\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\r\n    destroy(): Promise<void>;\r\n}\r\n","/**\r\n * @license Apache-2.0\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nexport const version = \"0.6.2\";\r\nexport * from \"./engine\";\r\nexport * from \"./segment-manager\";\r\n\r\nimport { Engine } from \"./engine\";\r\n\r\ndeclare const videojs: any;\r\n\r\ndeclare global {\r\n    interface Window {\r\n        p2pml: Record<string, unknown>;\r\n    }\r\n}\r\n\r\nexport function initHlsJsPlayer(player: any): void {\r\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\r\n        initHlsJsEvents(player, player.config.loader.getEngine());\r\n    }\r\n}\r\n\r\nexport function initClapprPlayer(player: any): void {\r\n    player.on(\"play\", () => {\r\n        const playback = player.core.getCurrentPlayback();\r\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\r\n            playback._hls._p2pm_linitialized = true;\r\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\r\n        }\r\n    });\r\n}\r\n\r\nexport function initFlowplayerHlsJsPlayer(player: any): void {\r\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\r\n}\r\n\r\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\r\n    player.ready(() => {\r\n        const options = player.tech_.options_;\r\n        if (\r\n            options &&\r\n            options.hlsjsConfig &&\r\n            options.hlsjsConfig.loader &&\r\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\r\n        ) {\r\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initVideoJsHlsJsPlugin(): void {\r\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\r\n        return;\r\n    }\r\n\r\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\r\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\r\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initMediaElementJsPlayer(mediaElement: any): void {\r\n\r\n\r\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n\r\n            if (event.data && event.data.length > 1) {\r\n                const frag = event.data[1].frag;\r\n                const byteRange =\r\n                    frag.byteRange.length !== 2\r\n                        ? undefined\r\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n            }\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n            await engine.destroy();\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\r\n                const engine: Engine = hls.config.loader.getEngine();\r\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\r\n    const iid = setInterval(() => {\r\n        if (player.hls && player.hls.config) {\r\n            clearInterval(iid);\r\n            Object.assign(player.hls.config, hlsjsConfig);\r\n            initHlsJsPlayer(player.hls);\r\n        }\r\n    }, 200);\r\n}\r\n\r\nfunction initHlsJsEvents(player: any, engine: Engine): void {\r\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\r\n        const frag = data.frag;\r\n        const byteRange =\r\n            frag.byteRange.length !== 2\r\n                ? undefined\r\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n    });\r\n    player.on(\"hlsDestroying\", async () => {\r\n        await engine.destroy();\r\n    });\r\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\r\n        if (errorData.details === \"bufferStalledError\") {\r\n            const htmlMediaElement = (player.media === undefined\r\n                ? player.el_ // videojs-contrib-hlsjs\r\n                : player.media) as HTMLMediaElement | undefined; // all others\r\n            if (htmlMediaElement) {\r\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n"],"sourceRoot":""}