{"version":3,"file":"795.chunk.js?v=3038","mappings":"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","sources":["webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\n\r\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\r\nimport { Segment } from \"./loader-interface\";\r\nimport { SegmentValidatorCallback /*, XhrSetupCallback */, SegmentUrlBuilder } from \"./hybrid-loader\";\r\n\r\nclass FilteredEmitter extends STEEmitter<\r\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\r\n> { }\r\n\r\nexport class HttpMediaManager extends FilteredEmitter {\r\n    private fetchRequests = new Map<string, { request?: Promise<Response>; fetchAbort: AbortController, segment: Segment, initialPriority: number, segmentUrl: string }>();\r\n    private failedSegments = new Map<string, number>();\r\n    private debug = Debug(\"p2pml:http-media-manager\");\r\n    private fetch: typeof fetch = (...args) => fetch(...args);\r\n\r\n    public constructor(\r\n        readonly settings: {\r\n            httpFailedSegmentTimeout: number;\r\n            httpUseRanges: boolean;\r\n            requiredSegmentsPriority: number;\r\n            segmentValidator?: SegmentValidatorCallback;\r\n            /* xhrSetup?: XhrSetupCallback; */\r\n            segmentUrlBuilder?: SegmentUrlBuilder;\r\n            localTransport?: typeof fetch;\r\n        }\r\n    ) {\r\n        super();\r\n\r\n        if (settings.localTransport) {\r\n            this.fetch = settings.localTransport;\r\n        }\r\n    }\r\n\r\n    public download = (segment: Segment, downloadedPieces?: ArrayBuffer[]): void => {\r\n        if (this.isDownloading(segment)) {\r\n            return;\r\n        }\r\n\r\n        this.cleanTimedOutFailedSegments();\r\n\r\n        this.emit(\"segment-start-load\", segment);\r\n\r\n        const segmentUrl = this.buildSegmentUrl(segment);\r\n\r\n        const fetchAbort = new AbortController();\r\n\r\n        this.fetchRequests.set(segment.id, { fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\r\n\r\n        this.debug(\"http segment download\", segmentUrl);\r\n\r\n        segment.requestUrl = segmentUrl;\r\n\r\n        const headers = new Headers();\r\n\r\n        if (segment.range) {\r\n            headers.append('Range', segment.range);\r\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\r\n            let bytesDownloaded = 0;\r\n            for (const piece of downloadedPieces) {\r\n                bytesDownloaded += piece.byteLength;\r\n            }\r\n\r\n            headers.append(\"Range\", `bytes=${bytesDownloaded}-`);\r\n\r\n            this.debug(\"continue download from\", bytesDownloaded);\r\n        } else {\r\n            downloadedPieces = undefined;\r\n        }\r\n\r\n        const signal = fetchAbort.signal;\r\n\r\n        const fetchRequest = this.fetch(segmentUrl, { headers, signal });\r\n\r\n        void this.setupFetchEvents(fetchRequest, segment, downloadedPieces)\r\n            .catch((err: Error) => {\r\n                /**\r\n                 * Handling all fetch errors here\r\n                 */\r\n\r\n                if (err.name === \"AbortError\") {\r\n                    /**\r\n                     * This may happen on video seeking\r\n                     * or halted video playing. In most\r\n                     * cases it is normal. For more info\r\n                     * look AbortController...\r\n                     */\r\n                    this.debug(\"Segment loading was aborted by user\", segment);\r\n                    return;\r\n                }\r\n\r\n                if (err.message === \"network error\") {\r\n                    this.debug(\"Segment loading is unavailable. No internet\", segment);\r\n\r\n                    const netError = Error(\"NETWORK_ERROR\");\r\n\r\n                    this.segmentFailure(segment, netError, segment.url);\r\n                    return;\r\n                }\r\n\r\n                if (err.message === \"Failed to fetch\") {\r\n                    /**\r\n                     * This error might occur in next cases:\r\n                     *   - Network error\r\n                     *   - Response with erroneous CORS headers\r\n                     *   - Unsupported protocol, e.g. HTTPS\r\n                     *   - Wrong request method\r\n                     */\r\n\r\n                    this.debug(\"Segment fetch failed\", segment);\r\n\r\n                    const fetchError = Error(\"FETCH_FAILED\");\r\n\r\n                    this.segmentFailure(segment, fetchError, segment.url);\r\n                    return;\r\n                }\r\n            });\r\n\r\n        /* if (this.settings.xhrSetup) {\r\n            this.settings.xhrSetup(xhr, segmentUrl);\r\n        } */\r\n\r\n        this.fetchRequests.set(segment.id, { request: fetchRequest, fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\r\n\r\n        return;\r\n    };\r\n\r\n    public updatePriority = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (!request) {\r\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\r\n        }\r\n\r\n        // Segment is now in high priority\r\n        // If the segment URL changed, retry the request with the new URL\r\n        if (\r\n            segment.priority <= this.settings.requiredSegmentsPriority &&\r\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\r\n            request.segmentUrl !== this.buildSegmentUrl(segment)\r\n        ) {\r\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\r\n            this.abort(segment)\r\n            this.download(segment)\r\n        }\r\n\r\n    }\r\n\r\n    public abort = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (request) {\r\n            request.fetchAbort.abort();\r\n            this.fetchRequests.delete(segment.id);\r\n            this.debug(\"http segment abort\", segment.id);\r\n        }\r\n    };\r\n\r\n    public isDownloading = (segment: Segment): boolean => {\r\n        return this.fetchRequests.has(segment.id);\r\n    };\r\n\r\n    public isFailed = (segment: Segment): boolean => {\r\n        const time = this.failedSegments.get(segment.id);\r\n        return time !== undefined && time > this.now();\r\n    };\r\n\r\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\r\n        return this.fetchRequests;\r\n    };\r\n\r\n    public getActiveDownloadsCount = (): number => {\r\n        return this.fetchRequests.size;\r\n    };\r\n\r\n    public destroy = (): void => {\r\n        this.fetchRequests.forEach((request) => request.fetchAbort.abort());\r\n        this.fetchRequests.clear();\r\n    };\r\n\r\n    private setupFetchEvents = async (fetch: Promise<Response>, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\r\n        const fetchResponse = await fetch as Response & { body: ReadableStream };\r\n\r\n        const dataReader = fetchResponse.body.getReader();\r\n\r\n        const contentLengthStr = fetchResponse.headers.get(\"Content-Length\") as string;\r\n\r\n        const contentLength = Number.parseFloat(contentLengthStr);\r\n\r\n        const dataBytes: Uint8Array = new Uint8Array(contentLength);\r\n\r\n        let nextChunkPos = 0;\r\n\r\n        if (Array.isArray(downloadedPieces) && fetchResponse.status === 206) {\r\n            for (const piece of downloadedPieces) {\r\n                const pieceBytes = new Uint8Array(piece);\r\n\r\n                dataBytes.set(pieceBytes, nextChunkPos);\r\n\r\n                nextChunkPos = piece.byteLength;\r\n            }\r\n        }\r\n\r\n        let read;\r\n\r\n        while (!(read = await dataReader.read()).done) {\r\n            const chunkBytes = read.value;\r\n\r\n            dataBytes.set(chunkBytes, nextChunkPos);\r\n\r\n            nextChunkPos += chunkBytes.length;\r\n\r\n            /** Events emitters */\r\n\r\n            this.emit(\"bytes-downloaded\", segment, chunkBytes.length);\r\n\r\n            if (contentLength) {\r\n                this.emit(\"segment-size\", segment, contentLength);\r\n            }\r\n        }\r\n\r\n        if (fetchResponse.status < 200 || fetchResponse.status >= 300) {\r\n            const err = Error(`Segment failure with HTTP code ${fetchResponse.status}`);\r\n            this.segmentFailure(segment, err, fetchResponse.url);\r\n            return;\r\n        }\r\n\r\n        await this.segmentDownloadFinished(segment, dataBytes.buffer, fetchResponse);\r\n    };\r\n\r\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, fetchResponse: Response) => {\r\n        segment.responseUrl = fetchResponse.url;\r\n\r\n        if (this.settings.segmentValidator) {\r\n            try {\r\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\r\n            } catch (error) {\r\n                this.debug(\"segment validator failed\", error);\r\n                this.segmentFailure(segment, error, fetchResponse.url);\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.emit(\"segment-loaded\", segment, data);\r\n    };\r\n\r\n    private segmentFailure = (segment: Segment, error: Error, responseUrl: string) => {\r\n        segment.responseUrl = responseUrl;\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\r\n        this.emit(\"segment-error\", segment, error);\r\n    };\r\n\r\n    private cleanTimedOutFailedSegments = () => {\r\n        const now = this.now();\r\n        const candidates: string[] = [];\r\n\r\n        this.failedSegments.forEach((time, id) => {\r\n            if (time < now) {\r\n                candidates.push(id);\r\n            }\r\n        });\r\n\r\n        candidates.forEach((id) => this.failedSegments.delete(id));\r\n    };\r\n\r\n    private buildSegmentUrl (segment: Segment) {\r\n        if (this.settings.segmentUrlBuilder) {\r\n            return this.settings.segmentUrlBuilder(segment);\r\n        }\r\n\r\n        return segment.url;\r\n    }\r\n\r\n    private now = () => performance.now();\r\n}\r\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\nimport { EventEmitter } from \"events\";\r\nimport Peer from \"simple-peer\";\r\n\r\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\r\nimport { HttpMediaManager } from \"./http-media-manager\";\r\nimport { P2PMediaManager } from \"./p2p-media-manager\";\r\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\r\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\r\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\r\n/*\r\nconst defaultSettings: HybridLoaderSettings = {\r\n    cachedSegmentExpiration: 5 * 60 * 1000,\r\n    cachedSegmentsCount: 30,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 1,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.1,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 10000,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 4000,\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 3,\r\n    p2pDownloadMaxPriority: 20,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};*/\r\n\r\n\r\nconst defaultSettings: HybridLoaderSettings & { localTransport?: typeof fetch } = {\r\n    cachedSegmentExpiration: 10 * 60 * 1000,\r\n    cachedSegmentsCount: 1000,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 3,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.06,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 1500,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 20,\r\n    p2pDownloadMaxPriority: 50,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};\r\n\r\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\r\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\r\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\r\n    private readonly httpManager: HttpMediaManager;\r\n    private readonly p2pManager: P2PMediaManager;\r\n    private segmentsStorage: SegmentsStorage;\r\n    private segmentsQueue: Segment[] = [];\r\n    private readonly bandwidthApproximator = new BandwidthApproximator();\r\n    private readonly settings: HybridLoaderSettings & { localTransport?: typeof fetch };\r\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\r\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n    private masterSwarmId?: string;\r\n\r\n    public static isSupported = (): boolean => {\r\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\r\n    };\r\n\r\n    public constructor(settings: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }> = {}) {\r\n        super();\r\n\r\n        this.settings = { ...defaultSettings, ...settings };\r\n\r\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\r\n\r\n        if (typeof bufferedSegmentsCount === \"number\") {\r\n            if (settings.p2pDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n\r\n            if (settings.httpDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n        }\r\n\r\n        this.segmentsStorage =\r\n            this.settings.segmentsStorage === undefined\r\n                ? new SegmentsMemoryStorage(this.settings)\r\n                : this.settings.segmentsStorage;\r\n\r\n        this.debug(\"loader settings\", this.settings);\r\n\r\n        this.httpManager = this.createHttpManager();\r\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\r\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\r\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\r\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\r\n        });\r\n\r\n        this.p2pManager = this.createP2PManager();\r\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\r\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\r\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.p2pManager.on(\"peer-data-updated\", async () => {\r\n            if (this.masterSwarmId === undefined) {\r\n                return;\r\n            }\r\n\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        });\r\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\r\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\r\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\r\n    }\r\n\r\n    private createHttpManager = () => {\r\n        return new HttpMediaManager(this.settings);\r\n    };\r\n\r\n    private createP2PManager = () => {\r\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\r\n    };\r\n\r\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            // Do once on first call\r\n            this.httpRandomDownloadInterval = setInterval(\r\n                this.downloadRandomSegmentOverHttp,\r\n                this.settings.httpDownloadProbabilityInterval\r\n            );\r\n\r\n            if (\r\n                this.settings.httpDownloadInitialTimeout > 0 &&\r\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\r\n            ) {\r\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\r\n                this.debugSegments(\r\n                    \"enable initial HTTP download timeout\",\r\n                    this.settings.httpDownloadInitialTimeout,\r\n                    \"per segment\",\r\n                    this.settings.httpDownloadInitialTimeoutPerSegment\r\n                );\r\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\r\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            this.masterSwarmId = segments[0].masterSwarmId;\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\r\n        }\r\n\r\n        this.debug(\"load segments\");\r\n\r\n        let updateSegmentsMap = false;\r\n\r\n        // stop all http requests and p2p downloads for segments that are not in the new load\r\n        for (const segment of this.segmentsQueue) {\r\n            if (!segments.find((f) => f.url === segment.url)) {\r\n                this.debug(\"remove segment\", segment.url);\r\n                if (this.httpManager.isDownloading(segment)) {\r\n                    updateSegmentsMap = true;\r\n                    this.httpManager.abort(segment);\r\n                } else {\r\n                    this.p2pManager.abort(segment);\r\n                }\r\n                this.emit(Events.SegmentAbort, segment);\r\n            }\r\n        }\r\n\r\n        if (this.debug.enabled) {\r\n            for (const segment of segments) {\r\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\r\n                    this.debug(\"add segment\", segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.segmentsQueue = segments;\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\r\n\r\n        if (await this.cleanSegmentsStorage()) {\r\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            updateSegmentsMap = true;\r\n        }\r\n\r\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\r\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\r\n    };\r\n\r\n    public getSettings = (): HybridLoaderSettings => {\r\n        return this.settings;\r\n    };\r\n\r\n    public getDetails = (): { peerId: string } => {\r\n        return {\r\n            peerId: this.p2pManager.getPeerId(),\r\n        };\r\n    };\r\n\r\n    public getBandwidthEstimate = (): number => {\r\n        return this.bandwidthApproximator.getBandwidth(this.now());\r\n    };\r\n\r\n    public destroy = async (): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval !== undefined) {\r\n            clearInterval(this.httpRandomDownloadInterval);\r\n            this.httpRandomDownloadInterval = undefined;\r\n        }\r\n\r\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n        this.segmentsQueue = [];\r\n        this.httpManager.destroy();\r\n        this.p2pManager.destroy();\r\n        this.masterSwarmId = undefined;\r\n        await this.segmentsStorage.destroy();\r\n    };\r\n\r\n    private processInitialSegmentTimeout = async () => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            return; // Instance destroyed\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            // Set one more timeout for a next segment\r\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\r\n        }\r\n    };\r\n\r\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        this.debugSegments(\r\n            \"process segments queue. priority\",\r\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\r\n        );\r\n\r\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        let updateSegmentsMap = false;\r\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\r\n\r\n        let httpAllowed = true;\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            let firstNotDownloadePriority: number | undefined;\r\n\r\n            for (const segment of this.segmentsQueue) {\r\n                if (!storageSegments.has(segment.id)) {\r\n                    firstNotDownloadePriority = segment.priority;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\r\n            httpAllowed =\r\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\r\n                (firstNotDownloadePriority !== undefined &&\r\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\r\n                    firstNotDownloadePriority <= 0);\r\n\r\n            if (httpAllowed) {\r\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\r\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\r\n            const segment = this.segmentsQueue[index];\r\n\r\n            if (storageSegments.has(segment.id)) {\r\n                continue;\r\n            }\r\n\r\n            // Segment priority changed, notify http manager\r\n            if (this.httpManager.isDownloading(segment)) {\r\n                this.httpManager.updatePriority(segment);\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                segment.priority <= this.settings.requiredSegmentsPriority &&\r\n                httpAllowed &&\r\n                !this.httpManager.isFailed(segment)\r\n            ) {\r\n                // Download required segments over HTTP\r\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\r\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.httpManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\r\n                    // Abort P2P download of the required segment if any and force HTTP download\r\n                    const downloadedPieces = this.p2pManager.abort(segment);\r\n                    this.httpManager.download(segment, downloadedPieces);\r\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\r\n                    updateSegmentsMap = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (this.p2pManager.isDownloading(segment)) {\r\n                continue;\r\n            }\r\n\r\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\r\n                // Download required segments over P2P\r\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\r\n\r\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\r\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.p2pManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\r\n                    if (this.p2pManager.download(segment)) {\r\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\r\n                segment.priority <= this.settings.p2pDownloadMaxPriority\r\n            ) {\r\n                if (this.p2pManager.download(segment)) {\r\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        return updateSegmentsMap;\r\n    };\r\n\r\n    private downloadRandomSegmentOverHttp = async () => {\r\n        if (\r\n            this.masterSwarmId === undefined ||\r\n            this.httpRandomDownloadInterval === undefined ||\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\r\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\r\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\r\n            this.settings.consumeOnly\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\r\n\r\n        const pendingQueue = this.segmentsQueue.filter(\r\n            (s) =>\r\n                !this.p2pManager.isDownloading(s) &&\r\n                !this.httpManager.isDownloading(s) &&\r\n                !segmentsMap.has(s.id) &&\r\n                !this.httpManager.isFailed(s) &&\r\n                s.priority <= this.settings.httpDownloadMaxPriority &&\r\n                !storageSegments.has(s.id)\r\n        );\r\n\r\n        if (pendingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\r\n            return;\r\n        }\r\n\r\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\r\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\r\n        this.httpManager.download(segment);\r\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n    };\r\n\r\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n        this.emit(Events.SegmentStartLoad, method, segment);\r\n    };\r\n\r\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.bandwidthApproximator.addBytes(bytes, this.now());\r\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\r\n\r\n    };\r\n\r\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\r\n    };\r\n\r\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\r\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        segment.data = data;\r\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\r\n\r\n        await this.segmentsStorage.storeSegment(segment);\r\n        this.emit(Events.SegmentLoaded, segment, peerId);\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n        this.processSegmentsQueue(storageSegments);\r\n        if (!this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\r\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\r\n        this.emit(Events.SegmentError, segment, details, peerId);\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n    };\r\n\r\n    private onSegmentSize = async (segment: Segment, size: number) => {\r\n        this.debugSegments(\"segment size\", segment.id, size);\r\n        this.emit(Events.SegmentSize, segment, size);\r\n    };\r\n\r\n    private getStreamSwarmId = (segment: Segment) => {\r\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\r\n    };\r\n\r\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\r\n\r\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\r\n            const streamSwarmId = this.getStreamSwarmId(segment);\r\n            const segmentId = segment.sequence;\r\n\r\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\r\n            if (segmentsIdsAndStatuses === undefined) {\r\n                segmentsIdsAndStatuses = [\"\", []];\r\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\r\n            }\r\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\r\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\r\n            segmentsStatuses.push(status);\r\n        };\r\n\r\n        for (const storageSegment of storageSegments.values()) {\r\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\r\n        }\r\n\r\n        for (const download of this.httpManager.getActiveDownloads().values()) {\r\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\r\n        }\r\n\r\n        return segmentsMap;\r\n    };\r\n\r\n    private onPeerConnect = async (peer: { id: string }) => {\r\n        this.emit(Events.PeerConnect, peer);\r\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\r\n            this.p2pManager.sendSegmentsMap(\r\n                peer.id,\r\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\r\n            );\r\n        }\r\n    };\r\n\r\n    private onPeerClose = (peerId: string) => {\r\n        this.emit(Events.PeerClose, peerId);\r\n    };\r\n\r\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\r\n        if (\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\r\n            data.incomplete !== undefined &&\r\n            data.incomplete <= 1\r\n        ) {\r\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\r\n\r\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n            if (this.masterSwarmId !== undefined) {\r\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\r\n        if (this.masterSwarmId === undefined) {\r\n            return false;\r\n        }\r\n\r\n        return this.segmentsStorage.clean(\r\n            this.masterSwarmId,\r\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\r\n        );\r\n    };\r\n\r\n    private now = () => {\r\n        return performance.now();\r\n    };\r\n}\r\n\r\nexport interface SegmentsStorage {\r\n    storeSegment: (segment: Segment) => Promise<void>;\r\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\r\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\r\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\r\n    destroy: () => Promise<void>;\r\n}\r\n\r\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\r\n/* export type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void; */\r\nexport type SegmentUrlBuilder = (segment: Segment) => string;\r\n\r\nexport type HybridLoaderSettings = {\r\n    /**\r\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\r\n     */\r\n    cachedSegmentExpiration: number;\r\n\r\n    /**\r\n     * Max number of segments that can be stored in the cache.\r\n     */\r\n    cachedSegmentsCount: number;\r\n\r\n    /**\r\n     * Enable/Disable peers interaction.\r\n     */\r\n    useP2P: boolean;\r\n\r\n    /**\r\n     * The peer will not upload segments data to the P2P network but still download from others.\r\n     */\r\n    consumeOnly: boolean;\r\n\r\n    /**\r\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\r\n     */\r\n    requiredSegmentsPriority: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from HTTP source.\r\n     */\r\n    simultaneousHttpDownloads: number;\r\n\r\n    /**\r\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\r\n     */\r\n    httpDownloadProbability: number;\r\n\r\n    /**\r\n     * Interval of the httpDownloadProbability check (in milliseconds).\r\n     */\r\n    httpDownloadProbabilityInterval: number;\r\n\r\n    /**\r\n     * Don't download segments over HTTP randomly when there is no peers.\r\n     */\r\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\r\n\r\n    /**\r\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\r\n     */\r\n    httpFailedSegmentTimeout: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over HTTP.\r\n     */\r\n    httpDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Try to download initial segments over P2P if the value is > 0.\r\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\r\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\r\n     */\r\n    httpDownloadInitialTimeout: number;\r\n\r\n    /**\r\n     * Use HTTP ranges requests where it is possible.\r\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\r\n     */\r\n    httpUseRanges: boolean;\r\n\r\n    /**\r\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\r\n     * this parameter sets additional timeout for a single sequential segment download\r\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\r\n     */\r\n    httpDownloadInitialTimeoutPerSegment: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from peers.\r\n     */\r\n    simultaneousP2PDownloads: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over P2P.\r\n     */\r\n    p2pDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\r\n     */\r\n    p2pSegmentDownloadTimeout: number;\r\n\r\n    /**\r\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\r\n     */\r\n    webRtcMaxMessageSize: number;\r\n\r\n    /**\r\n     * Torrent trackers (announcers) to use.\r\n     */\r\n    trackerAnnounce: string[];\r\n\r\n    /**\r\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\r\n     */\r\n    peerRequestsPerAnnounce: number;\r\n\r\n    /**\r\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\r\n     */\r\n    rtcConfig: RTCConfiguration;\r\n\r\n    /**\r\n     * Segment validation callback - validates the data after it has been downloaded.\r\n     */\r\n    segmentValidator?: SegmentValidatorCallback;\r\n\r\n    /**\r\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\r\n     */\r\n    /* xhrSetup?: unknown; */\r\n\r\n    /**\r\n     * Allow to modify the segment URL before HTTP request.\r\n     */\r\n    segmentUrlBuilder?: SegmentUrlBuilder;\r\n\r\n    /**\r\n     * A storage for the downloaded segments.\r\n     * By default the segments are stored in JavaScript memory.\r\n     */\r\n    segmentsStorage?: SegmentsStorage;\r\n};\r\n","import { LoaderContext } from \"hls.js\"\r\n\r\nexport type ByteRange = { length: number; offset: number } | undefined;\r\n\r\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\r\n  return context.rangeEnd && context.rangeStart !== undefined\r\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\r\n      : undefined;\r\n}\r\n\r\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\r\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\r\n}\r\n\r\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\r\n  if (byteRange === undefined) {\r\n      return undefined;\r\n  }\r\n\r\n  const end = byteRange.offset + byteRange.length - 1;\r\n\r\n  return `bytes=${byteRange.offset}-${end}`;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Events, Segment, LoaderInterface } from \"../../p2p-media-loader-core/lib\";\r\nimport { Manifest, Parser } from \"m3u8-parser\";\r\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\r\nimport { AssetsStorage, HlsJsEngineSettings } from \"./engine\";\r\n\r\nconst defaultSettings: SegmentManagerSettings = {\r\n    forwardSegmentCount: 20,\r\n    swarmId: undefined,\r\n    assetsStorage: undefined,\r\n};\r\n\r\nexport class SegmentManager {\r\n    public readonly loader: LoaderInterface;\r\n    private masterPlaylist: Playlist | null = null;\r\n    private readonly variantPlaylists = new Map<string, Playlist>();\r\n    private segmentRequest: SegmentRequest | null = null;\r\n    private readonly fetch: typeof fetch = (...args) => fetch(...args);\r\n    private playQueue: {\r\n        segmentSequence: number;\r\n        segmentUrl: string;\r\n        segmentByteRange: ByteRange;\r\n        playPosition?: {\r\n            start: number;\r\n            duration: number;\r\n        };\r\n    }[] = [];\r\n    private readonly settings: SegmentManagerSettings;\r\n\r\n    public constructor(loader: LoaderInterface, settings: Partial<HlsJsEngineSettings> = {}) {\r\n        this.settings = { ...defaultSettings, ...settings.segments };\r\n\r\n        this.loader = loader;\r\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\r\n        this.loader.on(Events.SegmentError, this.onSegmentError);\r\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\r\n\r\n        if (settings.loader && settings.loader.localTransport) {\r\n            this.fetch = settings.loader.localTransport;\r\n        }\r\n    }\r\n\r\n    public getSettings(): SegmentManagerSettings {\r\n        return this.settings;\r\n    }\r\n\r\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\r\n        const parser = new Parser();\r\n        parser.push(content);\r\n        parser.end();\r\n\r\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\r\n\r\n        if (playlist.manifest.playlists) {\r\n            this.masterPlaylist = playlist;\r\n\r\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\r\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\r\n                if (!found) {\r\n                    this.variantPlaylists.delete(key);\r\n                } else {\r\n                    variantPlaylist.streamSwarmId = streamSwarmId;\r\n                    variantPlaylist.streamId = \"V\" + index.toString();\r\n                }\r\n            }\r\n        } else {\r\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\r\n\r\n            if (found || this.masterPlaylist === null) {\r\n                // do not add audio and subtitles to variants\r\n                playlist.streamSwarmId = streamSwarmId;\r\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\r\n                this.variantPlaylists.set(requestUrl, playlist);\r\n                this.updateSegments();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\r\n        const assetsStorage = this.settings.assetsStorage;\r\n        let res: { response: string; responseURL: string } | undefined;\r\n\r\n        if (assetsStorage !== undefined) {\r\n            let masterSwarmId: string | undefined;\r\n            masterSwarmId = this.getMasterSwarmId();\r\n            if (masterSwarmId === undefined) {\r\n                masterSwarmId = url.split(\"?\")[0];\r\n            }\r\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\r\n\r\n            if (asset !== undefined) {\r\n                res = {\r\n                    responseURL: asset.responseUri,\r\n                    response: asset.data as string,\r\n                };\r\n            } else {\r\n                const fetch = await this.loadContent(url);\r\n\r\n                res = {\r\n                    responseURL: fetch.url,\r\n                    response: await fetch.text(),\r\n                };\r\n\r\n                void assetsStorage.storeAsset({\r\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\r\n                    masterSwarmId: masterSwarmId,\r\n                    requestUri: url,\r\n                    responseUri: res.responseURL,\r\n                    data: await res.response,\r\n                });\r\n            }\r\n        } else {\r\n            const fetch = await this.loadContent(url);\r\n\r\n            res = {\r\n                responseURL: fetch.url,\r\n                response: await fetch.text(),\r\n            };\r\n        }\r\n\r\n        this.processPlaylist(url, res.response, res.responseURL);\r\n        return res;\r\n    }\r\n\r\n    \r\n\r\n    public async loadSegment(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\r\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\r\n        const byteRangeString = byteRangeToString(byteRange);\r\n\r\n        if (!segmentLocation) {\r\n            let content: ArrayBuffer | undefined;\r\n\r\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\r\n            const assetsStorage = this.settings.assetsStorage;\r\n            if (assetsStorage !== undefined) {\r\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\r\n\r\n                let masterSwarmId: string | undefined;\r\n                masterSwarmId = this.getMasterSwarmId();\r\n\r\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\r\n                    }\r\n                }\r\n\r\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterManifestUri = result.value.requestUrl;\r\n                    }\r\n                }\r\n\r\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\r\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\r\n                    if (asset !== undefined) {\r\n                        content = asset.data as ArrayBuffer;\r\n                    } else {\r\n                        const fetch = await this.loadContent(url, byteRangeString);\r\n                        content = await fetch.arrayBuffer();\r\n                        void assetsStorage.storeAsset({\r\n                            masterManifestUri: masterManifestUri,\r\n                            masterSwarmId: masterSwarmId,\r\n                            requestUri: url,\r\n                            requestRange: byteRangeString,\r\n                            responseUri: fetch.url,\r\n                            data: content,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (content === undefined) {\r\n                const fetch = await this.loadContent(url, byteRangeString);\r\n                content = await fetch.arrayBuffer();\r\n            }\r\n\r\n            return { content, downloadBandwidth: 0 };\r\n        }\r\n\r\n        const segmentSequence =\r\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\r\n            segmentLocation.segmentIndex;\r\n\r\n        if (this.playQueue.length > 0) {\r\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\r\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\r\n                // Reset play queue in case of segment loading out of sequence\r\n                this.playQueue = [];\r\n            }\r\n        }\r\n\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\r\n        }\r\n\r\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\r\n            (resolve, reject) => {\r\n\r\n                this.segmentRequest = new SegmentRequest(\r\n                    url,\r\n                    byteRange,\r\n                    segmentSequence,\r\n                    segmentLocation.playlist.requestUrl,\r\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\r\n                        resolve({ content, downloadBandwidth }),\r\n                    (error) => reject(error)\r\n                );\r\n                \r\n            }\r\n        );\r\n\r\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\r\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\r\n\r\n        return promise;\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        const urlIndex = this.playQueue.findIndex(\r\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\r\n        );\r\n\r\n        if (urlIndex >= 0) {\r\n            this.playQueue = this.playQueue.slice(urlIndex);\r\n            this.playQueue[0].playPosition = { start, duration };\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\r\n            return;\r\n        }\r\n\r\n        const currentSegmentPosition = this.playQueue[0].playPosition;\r\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\r\n\r\n        if (segmentEndTime - playheadPosition < 0.2) {\r\n            // means that current segment is (almost) finished playing\r\n            // remove it from queue\r\n\r\n            this.playQueue = this.playQueue.slice(1);\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public abortSegment(url: string, byteRange: ByteRange): void {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === url &&\r\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\r\n        ) {\r\n            this.segmentRequest.onSuccess(undefined, 0);\r\n            this.segmentRequest = null;\r\n        }\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\r\n            this.segmentRequest = null;\r\n        }\r\n\r\n        this.masterPlaylist = null;\r\n        this.variantPlaylists.clear();\r\n        this.playQueue = [];\r\n\r\n        if (this.settings.assetsStorage !== undefined) {\r\n            await this.settings.assetsStorage.destroy();\r\n        }\r\n\r\n        await this.loader.destroy();\r\n    }\r\n\r\n    private updateSegments(): void {\r\n        if (!this.segmentRequest) {\r\n            return;\r\n        }\r\n\r\n        const segmentLocation = this.getSegmentLocation(\r\n            this.segmentRequest.segmentUrl,\r\n            this.segmentRequest.segmentByteRange\r\n        );\r\n        if (segmentLocation) {\r\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\r\n        }\r\n    }\r\n\r\n    private onSegmentLoaded = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentError = (segment: Segment, error: unknown) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(error);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentAbort = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private getSegmentLocation(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\r\n        for (const playlist of this.variantPlaylists.values()) {\r\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\r\n            if (segmentIndex >= 0) {\r\n                return { playlist: playlist, segmentIndex: segmentIndex };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\r\n        const segments: Segment[] = [];\r\n        const playlistSegments = playlist.manifest.segments;\r\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\r\n        let loadSegmentId: string | null = null;\r\n\r\n        let priority = Math.max(0, this.playQueue.length - 1);\r\n\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        for (\r\n            let i = segmentIndex;\r\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\r\n            ++i\r\n        ) {\r\n            const segment = playlist.manifest.segments[i];\r\n\r\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\r\n            const byteRange: ByteRange = segment.byterange;\r\n            const id = this.getSegmentId(playlist, initialSequence + i);\r\n\r\n            segments.push({\r\n                id: id,\r\n                url: url,\r\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\r\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\r\n                streamId: playlist.streamId,\r\n                sequence: (initialSequence + i).toString(),\r\n                range: byteRangeToString(byteRange),\r\n                priority: priority++,\r\n            });\r\n            if (requestFirstSegment && !loadSegmentId) {\r\n                loadSegmentId = id;\r\n            }\r\n        }\r\n\r\n        this.loader.load(segments, playlist.streamSwarmId);\r\n\r\n        if (loadSegmentId) {\r\n            const segment = await this.loader.getSegment(loadSegmentId);\r\n\r\n\r\n\r\n            if (segment) {\r\n                // Segment already loaded by loader\r\n                this.onSegmentLoaded(segment);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\r\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\r\n    }\r\n\r\n    private getMasterSwarmId() {\r\n        const settingsSwarmId =\r\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\r\n        if (settingsSwarmId !== undefined) {\r\n            return settingsSwarmId;\r\n        }\r\n\r\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\r\n    }\r\n\r\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\r\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\r\n                const url = new URL(\r\n                    this.masterPlaylist.manifest.playlists[i].uri,\r\n                    this.masterPlaylist.responseUrl\r\n                ).toString();\r\n                if (url === playlistUrl) {\r\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\r\n            found: false,\r\n            index: -1,\r\n        };\r\n    }\r\n\r\n    private async loadContent(\r\n        url: string,\r\n        range?: string\r\n    ): Promise<Response> {\r\n        const headers = new Headers();\r\n\r\n        if (range) {\r\n            headers.append('Range', range);\r\n        }\r\n\r\n        const fetchPromise = this.fetch(url, { headers });\r\n\r\n        fetchPromise.catch((err) => {\r\n            /**\r\n             * Handling all fetch errors here\r\n             */\r\n\r\n            // console.log(\"SegmentManager fetch error\", { err });\r\n        });\r\n\r\n        return fetchPromise;\r\n    }\r\n}\r\n\r\nclass Playlist {\r\n    public streamSwarmId = \"\";\r\n    public streamId?: string;\r\n\r\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\r\n\r\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\r\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\r\n            const segment = this.manifest.segments[i];\r\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\r\n\r\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\r\n        return new URL(segmentUrl, this.responseUrl).toString();\r\n    }\r\n}\r\n\r\nclass SegmentRequest {\r\n    public constructor(\r\n        readonly segmentUrl: string,\r\n        readonly segmentByteRange: ByteRange,\r\n        readonly segmentSequence: number,\r\n        readonly playlistRequestUrl: string,\r\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\r\n        readonly onError: (error: unknown) => void\r\n    ) {}\r\n}\r\n\r\nexport interface SegmentManagerSettings {\r\n    /**\r\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\r\n     */\r\n    forwardSegmentCount: number;\r\n\r\n    /**\r\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\r\n     * query parameters is used as the swarm ID if the parameter is not specified)\r\n     */\r\n    swarmId?: string;\r\n\r\n    /**\r\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\r\n     */\r\n    assetsStorage?: AssetsStorage;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { SegmentManager } from \"./segment-manager\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\r\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\r\n\r\nexport class HlsJsLoader {\r\n    private isLoaded = false;\r\n    private segmentManager: SegmentManager;\r\n    public stats: LoaderStats = {\r\n        loaded: 0,\r\n        total: 0,\r\n        aborted: false,\r\n        retry: 0,\r\n        chunkCount: 0,\r\n        bwEstimate: 0,\r\n        loading: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n        parsing: {\r\n            start: 0,\r\n            end: 0,\r\n        },\r\n        buffering: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n    };\r\n\r\n    public constructor(segmentManager: SegmentManager) {\r\n        this.segmentManager = segmentManager;\r\n    }\r\n\r\n    public async load(\r\n        context: LoaderContext,\r\n        _config: LoaderConfiguration,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): Promise<void> {\r\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n        if (((context as unknown) as { type: unknown }).type) {\r\n            try {\r\n                const result = await this.segmentManager.loadPlaylist(context.url);\r\n                this.isLoaded = true;\r\n                this.successPlaylist(result, context, callbacks);\r\n            } catch (e : any) {\r\n                this.error(e, context, callbacks);\r\n            }\r\n        } else if (((context as unknown) as { frag: unknown }).frag) {\r\n            const { loader } = this.segmentManager;\r\n            const byteRange = getByteRange(context)\r\n\r\n            const isSegment = (segment: Segment) => {\r\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\r\n            }\r\n\r\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\r\n            let updateStart: any = setInterval(() => {\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n            }, 200)\r\n\r\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.total = size\r\n            };\r\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\r\n\r\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.loaded += bytes\r\n            };\r\n\r\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\r\n\r\n                clearInterval(updateStart)\r\n                updateStart = undefined\r\n\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            };\r\n\r\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\r\n\r\n\r\n            try {\r\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\r\n                const { content } = result;\r\n                if (content) {\r\n                    this.isLoaded = true;\r\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\r\n                }\r\n\r\n            } catch (e : any) {\r\n                setTimeout(() => this.error(e, context, callbacks), 0);\r\n            } finally {\r\n\r\n                clearInterval(updateStart)\r\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\r\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\r\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            }\r\n\r\n\r\n\r\n\r\n        } else {\r\n            console.warn(\"Unknown load request\", context);\r\n        }\r\n    }\r\n\r\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\r\n        if (this.isLoaded) return;\r\n\r\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\r\n        this.stats.aborted = true;\r\n\r\n        const onAbort = callbacks?.onAbort;\r\n        if (onAbort) {\r\n            onAbort(this.stats, context, undefined);\r\n        }\r\n    }\r\n\r\n    private successPlaylist(\r\n        xhr: { response: string; responseURL: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = xhr.response.length;\r\n        this.stats.total = xhr.response.length;\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: xhr.responseURL,\r\n                data: xhr.response,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private successSegment(\r\n        content: ArrayBuffer,\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = content.byteLength;\r\n        this.stats.total = content.byteLength;\r\n\r\n        if (callbacks.onProgress) {\r\n            callbacks.onProgress(this.stats, context, content, undefined);\r\n        }\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: context.url,\r\n                data: content,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private error(\r\n        error: { code: number; text: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        callbacks.onError(error, context, undefined);\r\n    }\r\n\r\n    private static updateStatsToStartLoading (stats: LoaderStats) {\r\n        const start = performance.now();\r\n        stats.loading.start = start;\r\n        stats.loading.first = start;\r\n    }\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\r\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\r\nimport { HlsJsLoader } from \"./hlsjs-loader\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { ByteRange } from \"./byte-range\"\r\n\r\nexport interface HlsJsEngineSettings {\r\n    loader: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }>;\r\n    segments: Partial<SegmentManagerSettings>;\r\n}\r\n\r\nexport class Engine extends EventEmitter {\r\n    public static isSupported(): boolean {\r\n        return HybridLoader.isSupported();\r\n    }\r\n\r\n    private readonly loader: LoaderInterface;\r\n    private readonly segmentManager: SegmentManager;\r\n\r\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\r\n        super();\r\n\r\n        this.loader = new HybridLoader(settings.loader);\r\n        this.segmentManager = new SegmentManager(this.loader, settings);\r\n\r\n        Object.keys(Events)\r\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\r\n            .forEach((event) => this.loader.on(event, (...args: any[]) => this.emit(event, ...args)));\r\n    }\r\n\r\n    public createLoaderClass(): new () => unknown {\r\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        return class {\r\n            private impl: HlsJsLoader;\r\n            private context?: LoaderContext;\r\n            private callbacks?: LoaderCallbacks<LoaderContext>;\r\n            public stats: LoaderStats;\r\n\r\n            constructor() {\r\n                this.impl = new HlsJsLoader(engine.segmentManager);\r\n                this.stats = this.impl.stats;\r\n            }\r\n\r\n            load = async (\r\n                context: LoaderContext,\r\n                config: LoaderConfiguration,\r\n                callbacks: LoaderCallbacks<LoaderContext>\r\n            ) => {\r\n                this.context = context;\r\n                this.callbacks = callbacks;\r\n                this.impl.load(context, config, callbacks);\r\n\r\n            };\r\n\r\n            abort = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context, this.callbacks);\r\n                }\r\n            };\r\n\r\n            destroy = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context);\r\n                }\r\n            };\r\n\r\n            getResponseHeader = () => undefined;\r\n\r\n            static getEngine = () => {\r\n                return engine;\r\n            };\r\n        };\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        await this.segmentManager.destroy();\r\n    }\r\n\r\n    public getSettings(): {\r\n        segments: SegmentManagerSettings;\r\n        loader: unknown;\r\n    } {\r\n        return {\r\n            segments: this.segmentManager.getSettings(),\r\n            loader: this.loader.getSettings(),\r\n        };\r\n    }\r\n\r\n    public getDetails(): unknown {\r\n        return {\r\n            loader: this.loader.getDetails(),\r\n        };\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\r\n    }\r\n\r\n}\r\n\r\nexport interface Asset {\r\n    masterSwarmId: string;\r\n    masterManifestUri: string;\r\n    requestUri: string;\r\n    requestRange?: string;\r\n    responseUri: string;\r\n    data: ArrayBuffer | string;\r\n}\r\n\r\nexport interface AssetsStorage {\r\n    storeAsset(asset: Asset): Promise<void>;\r\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\r\n    destroy(): Promise<void>;\r\n}\r\n","/**\r\n * @license Apache-2.0\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nexport const version = \"0.6.2\";\r\nexport * from \"./engine\";\r\nexport * from \"./segment-manager\";\r\n\r\nimport { Engine } from \"./engine\";\r\n\r\ndeclare const videojs: any;\r\n\r\ndeclare global {\r\n    interface Window {\r\n        p2pml: Record<string, unknown>;\r\n    }\r\n}\r\n\r\nexport function initHlsJsPlayer(player: any): void {\r\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\r\n        initHlsJsEvents(player, player.config.loader.getEngine());\r\n    }\r\n}\r\n\r\nexport function initClapprPlayer(player: any): void {\r\n    player.on(\"play\", () => {\r\n        const playback = player.core.getCurrentPlayback();\r\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\r\n            playback._hls._p2pm_linitialized = true;\r\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\r\n        }\r\n    });\r\n}\r\n\r\nexport function initFlowplayerHlsJsPlayer(player: any): void {\r\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\r\n}\r\n\r\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\r\n    player.ready(() => {\r\n        const options = player.tech_.options_;\r\n        if (\r\n            options &&\r\n            options.hlsjsConfig &&\r\n            options.hlsjsConfig.loader &&\r\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\r\n        ) {\r\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initVideoJsHlsJsPlugin(): void {\r\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\r\n        return;\r\n    }\r\n\r\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\r\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\r\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initMediaElementJsPlayer(mediaElement: any): void {\r\n\r\n\r\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n\r\n            if (event.data && event.data.length > 1) {\r\n                const frag = event.data[1].frag;\r\n                const byteRange =\r\n                    frag.byteRange.length !== 2\r\n                        ? undefined\r\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n            }\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n            await engine.destroy();\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\r\n                const engine: Engine = hls.config.loader.getEngine();\r\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\r\n    const iid = setInterval(() => {\r\n        if (player.hls && player.hls.config) {\r\n            clearInterval(iid);\r\n            Object.assign(player.hls.config, hlsjsConfig);\r\n            initHlsJsPlayer(player.hls);\r\n        }\r\n    }, 200);\r\n}\r\n\r\nfunction initHlsJsEvents(player: any, engine: Engine): void {\r\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\r\n        const frag = data.frag;\r\n        const byteRange =\r\n            frag.byteRange.length !== 2\r\n                ? undefined\r\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n    });\r\n    player.on(\"hlsDestroying\", async () => {\r\n        await engine.destroy();\r\n    });\r\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\r\n        if (errorData.details === \"bufferStalledError\") {\r\n            const htmlMediaElement = (player.media === undefined\r\n                ? player.el_ // videojs-contrib-hlsjs\r\n                : player.media) as HTMLMediaElement | undefined; // all others\r\n            if (htmlMediaElement) {\r\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n"],"names":["Events","STEEmitter","EventEmitter","constructor","on","event","listener","super","emit","args","FilteredEmitter","HttpMediaManager","settings","fetchRequests","Map","failedSegments","debug","Debug","fetch","download","segment","downloadedPieces","this","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","fetchAbort","AbortController","set","id","initialPriority","priority","requestUrl","headers","Headers","range","append","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","signal","fetchRequest","setupFetchEvents","catch","err","name","message","fetchError","Error","segmentFailure","url","netError","request","updatePriority","get","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","__awaiter","fetchResponse","dataReader","body","getReader","contentLengthStr","contentLength","Number","parseFloat","dataBytes","Uint8Array","read","nextChunkPos","Array","isArray","status","pieceBytes","done","chunkBytes","value","length","segmentDownloadFinished","buffer","data","responseUrl","segmentValidator","Object","error","httpFailedSegmentTimeout","candidates","push","performance","localTransport","segmentUrlBuilder","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","MediaPeer","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","segmentData","offset","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","streamSwarmId","keys","swarmData","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","Buffer","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","P2PMediaManager","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","sha1","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","Client","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","SegmentsMemoryStorage","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","Peer","HybridLoader","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","SegmentManager","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","processPlaylist","content","parser","Parser","playlist","Playlist","manifest","playlists","variantPlaylist","found","updateSegments","loadPlaylist","res","getMasterSwarmId","asset","getAsset","responseURL","responseUri","response","loadContent","text","storeAsset","masterManifestUri","requestUri","loadSegment","segmentLocation","getSegmentLocation","byteRangeString","_a","result","next","arrayBuffer","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","setPlayingSegment","duration","urlIndex","findIndex","playPosition","setPlayingSegmentByCurrentTime","playheadPosition","currentSegmentPosition","abortSegment","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","fetchPromise","playlistRequestUrl","HlsJsLoader","segmentManager","isLoaded","stats","loaded","total","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","successSegment","off","console","warn","onAbort","xhr","onProgress","Engine","map","eventKey","createLoaderClass","engine","config","impl","getResponseHeader","version","initHlsJsPlayer","player","getEngine","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","addEventListener","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"sourceRoot":""}