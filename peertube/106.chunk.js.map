{"version":3,"file":"106.chunk.js?v=3038","mappings":"+MAGA,MAAMA,EAAsBC,EAAQ,MAE9BC,EAAcD,EAAQ,MAEtBE,EAAmB,CACvB,OACA,OACA,QAQF,SAASC,EACPC,EACAC,EACAC,EACAC,GAIA,OAqFF,SAAuBH,GACrB,GAAY,MAARA,EACF,MAAM,IAAII,MAAM,oCAElB,GAAyB,iBAAdJ,EAAKK,KACd,MAAM,IAAID,MAAM,yCAElB,GAAqC,mBAA1BJ,EAAKM,iBACd,MAAM,IAAIF,MAAM,qDA/FlBG,CAAaP,GAKf,SAAsBA,EAAWC,EAAwBC,EAA0BC,GACjF,MAAMK,GAAYC,EAAAA,EAAAA,SAAQT,EAAKK,MAAMK,cACrC,IAAIC,EAEAC,EADAC,EAAc,EAGlB,IAEID,EADEd,EAAiBgB,QAAQN,IAAc,EAC9BO,IAEAC,IAEb,MAAOC,GACP,OAAOd,EAASc,GAGlB,SAASF,IAYP,OAXAG,IAGAP,EAAaQ,iBAAiB,SAAS,SAASC,EAASH,GAGvD,OAFAN,EAAaU,oBAAoB,QAASD,GAEnCjB,EAASc,MAIlBN,EAAaQ,iBAAiB,iBAAkBG,GACzC,IAAIzB,EAAYG,EAAMW,GAG/B,SAASK,IAA8B,IAAdO,EAAc,wDACrC,MAAMC,EAASC,EAASzB,EAAKK,KAAMkB,GAGnCL,IACAP,EAAaQ,iBAAiB,SAAS,SAASC,EAASH,GAIvD,OAHAN,EAAaU,oBAAoB,QAASD,IAGX,IAA3BI,EAAOV,QAAQ,OAAsBY,GAAsB,GAExDvB,EAASc,MAElBN,EAAaQ,iBAAiB,iBAAkBG,GAEhD,MAAMK,EAAU,IAAIhC,EAAoBgB,GAClCiB,EAAWD,EAAQE,kBAAkBL,GAK3C,OAJAxB,EAAKM,mBAAmBwB,KAAKF,GAEzBf,IAAaF,EAAaE,YAAcA,GAErCc,EAGT,SAASD,IAAqC,IAAdH,EAAc,yDAC7B,IAAXA,EAAiBQ,QAAQC,IAAI,kDAC5BD,QAAQC,IAAI,kCAEjBhB,EAAeO,GAGjB,SAASL,SACce,IAAjBtB,IACFA,EAAeV,EAEfU,EAAaQ,iBAAiB,YAAY,WACxCN,EAAcZ,EAAKY,gBAKzB,SAASS,IACPX,EAAaU,oBAAoB,iBAAkBC,GAG/CpB,EAAKgC,UAAUvB,EAAawB,OAEhChC,EAAS,KAAMS,IAjFVwB,CAAYpC,EAAMC,EAAMC,EAAMC,GAiGvC,SAASsB,EAAUpB,GAA4B,IAAdkB,EAAc,wDAC7C,MAAMc,GAAM5B,EAAAA,EAAAA,SAAQJ,GAAMK,cAC1B,MAAY,SAAR2B,EACK,6CAGG,UAARA,GACa,IAAXd,EAAwB,iCAErB,wCAHT,E,sEC1HF,MAAMe,UAAsBC,EAAAA,EAG1BC,YAAaC,GACXC,MAAMD,GAENE,KAAKC,QAAQ,GAAGC,OAAO,CACrBC,OAAQ,QAKd,MAAMC,UAA2BR,EAAAA,EAG/BC,cACEE,MAAM,yBAENC,KAAKC,QAAQ,GAAGC,OAAO,CACrBG,UAAW,qBAKX,MAAOC,UAA2BC,EAAAA,aAmBtCV,YAAaW,EAAqBjD,GAYhC,GAXAwC,QAbM,KAAAU,WAA0D,GAE1D,KAAAC,aAAkD,GAaxDV,KAAKW,aAAe,qBAEfpD,IAAMA,EAAO,IACdA,EAAKqD,SAAWrD,EAAKqD,QAAQC,SAAUb,KAAKW,cAAgBpD,EAAKqD,QAAQC,SACxEb,KAAKW,cAAgB,WAE1BX,KAAKc,gBAAgB,KAErBd,KAAKQ,YAAcO,OAAOP,IACrBR,KAAKQ,YAAa,MAAM,IAAI/C,MAAM,yCAEvCuC,KAAKgB,OAASD,OAAOxD,EAAKyD,SAAWC,EAAAA,EAEjCjB,KAAKgB,SAAWC,EAAAA,IAClBjB,KAAKkB,gBAAmBlB,KAAKgB,OAAShB,KAAKQ,aAAgBR,KAAKQ,YAChER,KAAKmB,eAAiBC,KAAKC,KAAKrB,KAAKgB,OAAShB,KAAKQ,aAAe,GAGpER,KAAKsB,GAAK,IAAI3B,EAAcK,KAAKW,cAEjCX,KAAKuB,aAAe,IAAInB,EAExBJ,KAAKwB,aAGPC,IAAKC,EAAeC,EAAaC,GAC/B,MAAMC,EAAeH,IAAU1B,KAAKmB,eACpC,OAAIU,GAAeF,EAAIX,SAAWhB,KAAKkB,gBAC9BlB,KAAK8B,SAASF,EAAI,IAAInE,MAAM,6BAA+BuC,KAAKkB,kBAEpEW,GAAeF,EAAIX,SAAWhB,KAAKQ,aAKxCR,KAAKU,aAAagB,IAAS,EAG3B1B,KAAKS,WAAWsB,KAAK,CAAEC,GAAIN,EAAOC,IAAAA,EAAKC,GAAAA,SAEnC5B,KAAKiC,iBAGTjC,KAAKiC,eAAiBC,YAAW,KAAWC,EAAAA,EAAAA,IAAAA,UAAAA,OAAAA,GAAAA,YAC1C,MAAMC,EAAapC,KAAKS,WACxBT,KAAKS,WAAa,GAClBT,KAAKiC,oBAAiB3C,EAEtB,UACQU,KAAKsB,GAAGe,YAAY,KAAMrC,KAAKsB,GAAGnB,QAAQ,IACvCH,KAAKsB,GAAGnB,OAAOmC,QAAQF,EAAWG,KAAIC,IAAK,CAAGR,GAAIQ,EAAER,GAAIL,IAAKa,EAAEb,WAExE,MAAOrD,GACPc,QAAQC,IAAI,mDAAoD,CAAEf,IAAAA,IAElE8D,EAAWK,SAAQD,GAAKxC,KAAKU,aAAc8B,EAAER,IAAOQ,EAAEb,MAPxD,QASES,EAAWK,SAAQD,GAAKA,EAAEZ,YAE3BtB,EAAmBoC,qBA5Bb1C,KAAK8B,SAASF,EAAI,IAAInE,MAAM,wBAA0BuC,KAAKQ,cA+BtEmC,IAAKjB,EAAenE,EAAWqE,GAC7B,GAAoB,mBAATrE,EAAqB,OAAOyC,KAAK2C,IAAIjB,EAAO,KAAMnE,GAG7D,MAAMqF,EAAc5C,KAAKU,aAAagB,GACtC,QAAoBpC,IAAhBsD,EAA2B,CAC7B,MAAMtE,EAAM,IAAIb,MAAM,mBAGtB,OAFAa,EAAG,UAAe,EAEXuE,EAAQf,UAAS,IAAMF,EAAGtD,KAInC,IAAoB,IAAhBsE,EAAsB,OAAOhB,EAAG,KAAMgB,GAG1C5C,KAAKsB,GAAGe,YAAY,IAAKrC,KAAKsB,GAAGnB,QAAQ,KAAWgC,EAAAA,EAAAA,IAAAA,UAAAA,OAAAA,GAAAA,YAClD,MAAMW,QAAe9C,KAAKsB,GAAGnB,OAAOwC,IAAI,CAAEX,GAAIN,IAC9C,QAAepC,IAAXwD,EAAsB,OAAOlB,EAAG,KAAMmB,EAAOC,MAAM,IAEvD,MAAMrB,EAAMmB,EAAOnB,IACnB,IAAKpE,EAAM,OAAOyC,KAAK8B,SAASF,EAAI,KAAMD,GAE1C,MAAMsB,EAAS1F,EAAK0F,QAAU,EACxBC,EAAM3F,EAAKyD,QAAWW,EAAIX,OAASiC,EACzC,OAAOrB,EAAG,KAAMD,EAAIwB,MAAMF,EAAQC,EAAMD,SAEzCG,OAAM9E,IACLc,QAAQiE,MAAM/E,GACPsD,EAAGtD,MAIdgF,MAAO1B,GACL,OAAO5B,KAAKuD,QAAQ3B,GAGhB2B,QAAS3B,G,+CACb,IAqBE,OApBI5B,KAAKS,aACP+C,aAAaxD,KAAKiC,gBAClBjC,KAAKS,WAAa,MAEhBT,KAAKyD,kBACPC,cAAc1D,KAAKyD,iBACnBzD,KAAKyD,gBAAkB,MAGrBzD,KAAKsB,KACPtB,KAAKsB,GAAGgC,cAEFtD,KAAK2D,aAAa3D,KAAKW,eAG3BX,KAAKuB,eACPvB,KAAKuB,aAAa+B,QAClBtD,KAAKuB,aAAe,MAGfK,IACP,MAAOtD,GAEP,OADAc,QAAQiE,MAAM,uCAAwC/E,GAC/CsD,EAAGtD,OAINkD,aACNxB,KAAK4D,kBAEL5D,KAAKyD,gBAAkBI,aAAY,KAAW1B,EAAAA,EAAAA,IAAAA,UAAAA,OAAAA,GAAAA,YAC5CnC,KAAK4D,sBACJtD,EAAmBwD,qBAGVF,kB,+CACZ,IAAIG,EAA4C,GAEhD,UACQ/D,KAAKuB,aAAac,YAAY,KAAMrC,KAAKuB,aAAalB,WAAW,KAAW8B,EAAAA,EAAAA,IAAAA,UAAAA,OAAAA,GAAAA,kBAE1EnC,KAAKuB,aAAalB,UAAUoB,IAAI,CACpC/D,KAAMsC,KAAKW,aACXqD,YAAY,IAAIC,MAAOC,UAAY5D,EAAmB6D,wBAGxD,MAAMC,GAAM,IAAIH,MAAOC,UACvBH,QAA8B/D,KAAKuB,aAAalB,UAAUgE,MAAM,cAAcC,MAAMF,GAAKG,eAE3F,MAAOjG,GACPc,QAAQiE,MAAM,uDAAwD/E,GAGxE,IAAK,MAAMkG,KAAwBT,QAC3B/D,KAAK2D,aAAaa,EAAqB9G,SAInCiG,aAAchD,G,+CAC1B,MAAM8D,EAAa,IAAI9E,EAAcgB,GACrCvB,QAAQC,IAAI,kCAAmCsB,GAE/C,UACQ8D,EAAWC,eAEX1E,KAAKuB,aAAac,YAAY,KAAMrC,KAAKuB,aAAalB,WAAW,IAC9DL,KAAKuB,aAAalB,UAAUgE,MAAM,CAAE3G,KAAMiD,IAAgB+D,WAEnE,MAAOpG,GACPc,QAAQiE,MAAM,oBAAqB1C,EAAcrC,OAI7CwD,SAAcF,EAAoCtD,EAAYqG,GACpE9B,EAAQf,UAAS,IAAMF,EAAGtD,EAAKqG,SAAMrF,IApMfgB,EAAAA,iBAAmB,IACnBA,EAAAA,oBAAsB,IACtBA,EAAAA,sBAAwB,I,cCnBlD,MAAMsE,EAAkB3H,EAAQ,MAQ1B4H,EAASC,IAAAA,UAAkB,UAEjC,MAAMC,UAAyBF,EA6C7BhF,YAAamF,EAAwBC,GACnClF,MAAMiF,GAzCS,KAAAzF,UAAoB,EACpB,KAAA2F,UAAoB,EAGpB,KAAAC,UAAY,CAC3BC,eAAgB,IAChBC,uBAAwB,IACxBC,+BAAgC,GAChCC,8BAA+B,IAC/BC,qCAAsC,IACtCC,mCAAoC,GAGrB,KAAAC,WAAa,IAAIC,EAAW,CAC3CC,QAAS,CACPC,WAAWC,EAAAA,EAAAA,OAEbC,KAAK,IAQC,KAAAC,wBAAyB,EAEzB,KAAAC,gBAAiB,EACjB,KAAAC,wBAAyB,EACzB,KAAAC,6BAA8B,EAC9B,KAAAC,kBAAmB,EAQnB,KAAAC,eAA2B,GAKjCrG,KAAKkF,WAAYoB,EAAAA,EAAAA,IAAUrB,EAAQC,WAGnClF,KAAKT,SAAW0F,EAAQ1F,SACxBS,KAAKoG,mBAAoBG,EAAAA,EAAAA,MAEzBvG,KAAKwG,WAAavB,EAAQuB,WAC1BxG,KAAKyG,cAAgBxB,EAAQwB,cAE7BzG,KAAK0G,sBAAwB1G,KAAKgF,OAAO2B,IACzC3G,KAAK4G,cAAgB3B,EAAQ2B,cAE7B5G,KAAKgF,OAAO6B,OAAM,KACM7G,KAAKgF,OAAO8B,SAQlC9G,KAAKgF,OAAO+B,SAAS9B,EAAQwB,eAE7BzG,KAAKgH,mBACLhH,KAAKiH,0BAELjH,KAAKgF,OAAOkC,IAAI,QAAQ,KAEtBlH,KAAKmH,6BAA+BjF,YAAW,IAAMlC,KAAKoH,2BAA2BpH,KAAKmF,UAAUE,8BAK1GgC,UACE7D,aAAaxD,KAAKsH,iBAClB9D,aAAaxD,KAAKuH,yBAClB/D,aAAaxD,KAAKmH,8BAElBzD,cAAc1D,KAAKwH,qBACnB9D,cAAc1D,KAAKyH,qBAGnBzH,KAAK0H,eAAe1H,KAAK2H,kBAAkB,GAE3C3H,KAAK4H,sBAGPC,yBACE,OAAO7H,KAAK2H,iBAAmB3H,KAAK2H,iBAAiBG,WAAW9F,IAAM,EAGxE+F,gBACEC,GAMwC,IALxC/C,EAKwC,uDADpC,GACJgD,EAAwC,uDAArB,OAGnB,IAAKD,EAAW,CACd,MAAME,GAAwBC,EAAAA,EAAAA,MAC9BH,EAAYE,EACRlI,KAAKoI,mBAAmBF,GACxBlI,KAAKqI,uBAGX,IAAKL,EAEH,MAAMvK,MAAM,yDAkBd,QAA8B6B,IAA1BU,KAAK2H,kBAAkC3H,KAAK2H,iBAAiBW,YAAcN,EAAUM,UACvF,OAIFtI,KAAKuI,sBAKJvI,KAAKgF,OAAe2B,IAAM,KAAM,EACjC,MAAM6B,EAAkBxI,KAAKgF,OAAOyD,eAE9BC,EAAoB1I,KAAK2H,iBAK/B,GAJA3H,KAAK2H,iBAAmBK,GAIpBW,EAAAA,EAAAA,OAAW3I,KAAKoG,iBAClB,OAAOpG,KAAK4I,eAAe3D,GAAS,KAClCjF,KAAKgF,OAAOyD,aAAaD,GAClBP,OAKXjI,KAAK6I,WAAW7I,KAAK2H,iBAAiBW,UAAWI,EAAmBzD,GAAS,KAC3EjF,KAAKgF,OAAOyD,aAAaD,GAClBP,OAGTjI,KAAK8I,gBACL9I,KAAK+I,QAAQ,mBAAoB,CAAEC,KAAMhJ,KAAKiG,eAAgBgD,aAAcjJ,KAAK2H,iBAAiBG,WAAW9F,KAG/GkH,iBAAkBD,GAA+B,IAATE,EAAS,uDAAD,EAE9C,MAAMjL,EAAc8B,KAAKgF,OAAO9G,cACf8B,KAAKgF,OAAOoE,UAI3BpJ,KAAKgF,OAAOqE,cAAcC,OAIP,IAAjBL,GAEFjJ,KAAKgF,OAAOuE,SAAS,kCACrBvJ,KAAKgF,OAAOwE,YAAYC,SAGxBzJ,KAAKgF,OAAO0E,YAAY,kCACxB1J,KAAKgF,OAAOwE,YAAYF,QAG1B,MAAMK,EAAe3J,KAAKwG,WAAWoD,MAAKC,GAAKA,EAAE/B,WAAW9F,KAAOiH,IAC7DhE,EAAU,CACd6E,WAAW,EACXX,MAAAA,EACAY,KAAM7L,EAAeiL,EAAQ,KAG/BnJ,KAAK+H,gBAAgB4B,EAAc1E,GAGrCyC,eAAgBM,GAA4C,IAAtBgC,IAAsB,8DACxC1K,IAAd0I,GAA2BhI,KAAK0F,WAAW/C,IAAIqF,EAAUM,cACnC,IAApB0B,GAA4BhK,KAAK/B,UAAY+B,KAAK/B,SAASsF,SAASvD,KAAK/B,SAASsF,UAEtFvD,KAAK0F,WAAWuE,OAAOjC,EAAUM,YAIrC4B,uBACElK,KAAKiG,gBAAiB,EACtBjG,KAAK+I,QAAQ,mBAAoB,CAAEC,KAAMhJ,KAAKiG,eAAgBgD,aAAcjJ,KAAK6H,2BAGnFsC,yBACiB,KADoB,2DACdnK,KAAKkG,wBAAyB,GAEnDlG,KAAKiG,gBAAiB,EACtBjG,KAAK+I,QAAQ,uBAAwB,CAAEqB,SAAUpK,KAAKkG,yBACtDlG,KAAK+I,QAAQ,mBAAoB,CAAEC,KAAMhJ,KAAKiG,eAAgBgD,aAAcjJ,KAAK6H,2BAGnFwC,2BACE,OAAOrK,KAAKkG,uBAGdoE,aACE,OAAOtK,KAAKY,QAGd2J,sBACE,OAAOvK,KAAK2H,iBAGNkB,WACN2B,EACA9B,EACAzD,EACAgD,GAEA,IAAKuC,EAAoB,OAAOxK,KAAK4I,eAAe3D,EAASgD,GAE7D,MAAMwC,EAAazK,KAAKY,QAClB8J,EAAiB,CAErBC,MAAO,SAAUnK,EAAqBoK,GACpC,OAAO,IAAIhG,EAAgB,IAAItE,EAAmBE,EAAaoK,GAAY,CACzEC,IAAK,QAKX7K,KAAKY,QAAUZ,KAAK0F,WAAWoF,IAAIN,EAAoBE,GAAgB9J,IACjE6J,IAEFzK,KAAK+K,YAAYN,GAGdxF,EAAQkE,OACTnJ,KAAKgL,wBAAwBpK,EAAQqK,MAAO,GAAKhG,EAAQkE,QAI7DnJ,KAAKsH,gBAAkBpF,YAAW,KAGhClC,KAAK4H,sBAEL,MAAMwB,EAASpJ,KAAKgF,OAAOoE,SAE3BpJ,KAAK0H,eAAegB,GAGhBzD,EAAQ8E,MAAM/J,KAAKgF,OAAO9G,YAAY+G,EAAQ8E,MAGlD3M,EAAYwD,EAAQqK,MAAO,GAAKjL,KAAK4G,cADV,CAAErH,UAAU,EAAO2L,UAAU,IACgB,CAAC5M,EAAKL,KAG5E,GAFA+B,KAAK/B,SAAWA,EAEZK,EAAK,OAAO0B,KAAK4I,eAAe3D,EAASgD,GAI7C/F,YAAW,IACFlC,KAAKmL,WAAU7M,GAEhBA,EAAY2J,EAAK3J,IAEjB2G,EAAQ8E,MAAM/J,KAAK+J,KAAK9E,EAAQ8E,OACV,IAAtB9E,EAAQ6E,YAAkC,IAAXV,GAAiBpJ,KAAKgF,OAAOoG,QAEzDnD,QAER,SAGJhD,EAAQkE,OAAS,MAGtBnJ,KAAKY,QAAQyK,GAAG,SAAU/M,GAAac,QAAQiE,MAAM/E,KAErD0B,KAAKY,QAAQyK,GAAG,WAAY/M,IAU1B,IAA6D,IAAzDA,EAAIgN,QAAQnN,QAAQ,gCAGxB,IAAsD,IAAlDG,EAAIgN,QAAQnN,QAAQ,yBAAxB,CAMA,IAAoD,IAAhDG,EAAIgN,QAAQnN,QAAQ,uBAA+B,CACrDiB,QAAQiE,MAAM,+DACd,MAAMkI,EAAa,CAAEzB,WAAW,EAAMC,KAAM9E,EAAQ8E,MACpD,OAAO/J,KAAK6I,WAAW7I,KAAKY,QAAL,GAAsB8H,EAAmB6C,EAAYtD,IAIhC,IAA1C3J,EAAIgN,QAAQnN,QAAQ,kBACtB6B,KAAKwL,YAAYlN,QAbjBc,QAAQC,IAAIf,MAmBV6M,UAAWlD,GAEZA,IAAMA,EAAO,cAElB,MAAMwD,EAAczL,KAAKgF,OAAOxF,OAEhC,YAAoBF,IAAhBmM,EAEKA,EAAYC,MAAK,IAAMzD,MAAQ7E,OAAO9E,IACzC,IAAmD,IAA/CA,EAAIgN,QAAQnN,QAAQ,sBAWxB,OAPAiB,QAAQC,IAAI,SACZW,KAAKgF,OAAOoG,QACZpL,KAAKgF,OAAOwE,YAAYC,OACxBzJ,KAAKgF,OAAO0E,YAAY,oBACxB1J,KAAKgF,OAAO0E,YAAY,mCACxB1J,KAAKgF,OAAO0E,YAAY,kCAEjBzB,OAINA,IAKD8B,KAAM4B,GACZ3L,KAAKgF,OAAO9G,YAAYyN,GACxB3L,KAAKgF,OAAO4G,oBAGNxD,mBAAoByD,GAC1B,QAAwBvM,IAApBU,KAAKwG,WAA0B,OAEnC,MAAMyE,EAAQjL,KAAKwG,WAAWsF,QAAOjC,GAAyB,IAApBA,EAAE/B,WAAW9F,KAEvD,GAAqB,IAAjBiJ,EAAMjK,OAAc,OACxB,GAAqB,IAAjBiK,EAAMjK,OAAc,OAAOiK,EAAM,GAGrC,GAAIjL,KAAKY,SAAqC,IAA1BZ,KAAKY,QAAQmL,UAAkB/L,KAAKgF,OAAOgH,QAAS,OAAOhM,KAAK2H,iBAE/EkE,IAAsBA,EAAuB7L,KAAKiM,iCAGvD,MAAMC,EAAelM,KAAK4G,cAAcuF,aAIxC,IAAIC,EAAgBnB,EAAM,GAAGnD,WAAW9F,GACxC,IAAK,IAAIqK,EAAIpB,EAAMjK,OAAS,EAAGqL,GAAK,EAAGA,IAAK,CAC1C,MAAMpD,EAAegC,EAAMoB,GAAGvE,WAAW9F,GACzC,GAAqB,IAAjBiH,GAAsBA,GAAgBiD,EAAc,CACtDE,EAAgBnD,EAChB,OAKJ,MAAMqD,EAAgBrB,EAAMa,QAAOjC,GAAKA,EAAE/B,WAAW9F,IAAMoK,IAC/BN,QAAOjC,IACN,MAAM0C,EAAe1C,EAAE2C,KAAOxM,KAAKyG,cACnC,IAAIgG,EAAYF,EAOhB,QAJKvM,KAAK2H,kBAAoBkC,EAAE/B,WAAW9F,GAAKhC,KAAK2H,iBAAiBG,WAAW9F,MAC/EyK,GAAeF,EAAcvM,KAAKmF,UAAUG,+BAAkC,KAGzEuG,EAAuBY,KAI3D,OAA6B,IAAzBH,EAActL,QAAqB0L,EAAAA,EAAAA,IAAyBzB,IAEzD0B,EAAAA,EAAAA,IAAyBL,GAG1BL,gCACN,MAAMW,EAAQxL,KAAKyJ,IAAI7K,KAAKqG,eAAerF,OAAShB,KAAKmF,UAAUM,mCAAoC,GACjGoH,EAAqB7M,KAAKqG,eAAelD,MAAMyJ,EAAO5M,KAAKqG,eAAerF,QAChF,GAAkC,IAA9B6L,EAAmB7L,OAAc,OAAQ,EAE7C,MAAM8L,EAAMD,EAAmBE,QAAO,CAACC,EAAGC,IAAMD,EAAIC,IAC9CC,EAAmB9L,KAAK+L,MAAML,EAAMD,EAAmB7L,QAK7D,OAFAoM,EAAAA,EAAAA,IAAqBF,GAEdA,EAGDlG,mBAGN,GAFAhH,KAAKqN,iBAEDrN,KAAKT,SAGP,OAFAS,KAAKgF,OAAOwE,YAAYF,OAEjBtJ,KAAK+H,qBAAgBzI,EAAW,CAAEwK,WAAW,EAAMC,KAAM/J,KAAKkF,YAIvE,MAAMoI,EAAUtN,KAAKgF,OAAOxF,KAAK+N,KAAKvN,KAAKgF,QAC1ChF,KAAKgF,OAAexF,KAAO,KAC1BQ,KAAKgF,OAAOuE,SAAS,mCACrBvJ,KAAKgF,OAAOxF,KAAO8N,EAEnBtN,KAAK+H,qBAAgBzI,EAAW,CAAEwK,WAAW,EAAMC,KAAM/J,KAAKkF,aAI1DkC,0BACNpH,KAAKyH,oBAAsB5D,aAAY,KAGrC,QAAqBvE,IAAjBU,KAAKY,SAA0C,OAAjBZ,KAAKY,QAAkB,OACzD,IAA4B,IAAxBZ,KAAKiG,eAA0B,OACnC,IAAyC,IAArCjG,KAAKmG,4BAAsC,OAE/C,MAAM9I,EAAO2C,KAAKoI,qBAClB,IAAIoF,GAAmB,EACnBC,EAAwB,EAGxBzN,KAAK0N,mBAAqBrQ,EAAKyK,WAAW9F,GAAKhC,KAAK2H,iBAAiBG,WAAW9F,GAClFwL,GAAmB,EACVnQ,EAAKyK,WAAW9F,GAAKhC,KAAK2H,iBAAiBG,WAAW9F,KAC/DwL,GAAmB,EACnBC,EAAwBzN,KAAKmF,UAAUK,uCAGhB,IAArBgI,IACFxN,KAAKkJ,iBAAiB7L,EAAKyK,WAAW9F,GAAIyL,GAG1CzN,KAAKmG,6BAA8B,EAEnCnG,KAAKuH,wBAA0BrF,YAAW,KACxClC,KAAKmG,6BAA8B,IAClCnG,KAAKmF,UAAUI,kCAEnBvF,KAAKmF,UAAUE,wBAGZqI,kBACN,OAAO1N,KAAKgF,QAAUhF,KAAKgF,OAAO2I,SAAS,eAGrC1G,0BACNjH,KAAKwH,oBAAsB3D,aAAY,KAIrC,QAAqBvE,IAAjBU,KAAKY,QAGT,OAAqB,OAAjBZ,KAAKY,QAAyBZ,KAAKgF,OAAO+D,QAAQ,WAAW,IAG3B,IAAlC/I,KAAK0F,WAAWkI,eAAqB5N,KAAKqG,eAAetE,KAAK/B,KAAK0F,WAAWkI,eAI3E5N,KAAKgF,OAAO+D,QAAQ,UAAW,CACpC8E,OAAQ,aACRC,KAAM,CACJF,cAAe,EACfG,YAAa,EACbC,WAAY,EACZC,SAAU,GAEZC,IAAK,CACHN,cAAe5N,KAAKY,QAAQgN,cAC5BO,SAAUnO,KAAKY,QAAQuN,SACvBJ,YAAa/N,KAAKY,QAAQmN,YAC1BC,WAAYhO,KAAKY,QAAQoN,WACzBC,SAAUjO,KAAKY,QAAQqN,eAG1BjO,KAAKmF,UAAUC,gBAGZwD,eAAgB3D,EAAsBgD,GAG5C,MAAMmB,EAASpJ,KAAKgF,OAAOoE,SAE3BpJ,KAAKmK,uBAAsB,GAE3BnK,KAAK0H,eAAe1H,KAAK2H,kBAAkB,GAC3C3H,KAAKY,QAAU,KAGfZ,KAAKgF,OAAOkC,IAAI,SAAS,IAAMlH,KAAKoO,uBAEpC,MAAMC,EAAUrO,KAAK2H,iBAAiB2G,QAStC,OARAtO,KAAKgF,OAAO2B,IAAM3G,KAAK0G,sBACvB1G,KAAKgF,OAAO2B,IAAI0H,GAEhBrO,KAAK8I,gBAGL9I,KAAKgF,OAAO+D,QAAQ,gBAEb/I,KAAKmL,WAAU7M,GAEhBA,GAAO2J,EAAaA,EAAK3J,IAEzB2G,EAAQ8E,MAAM/J,KAAK+J,KAAK9E,EAAQ8E,OACV,IAAtB9E,EAAQ6E,YAAkC,IAAXV,IACjChK,QAAQC,IAAI,UACZW,KAAKgF,OAAOoG,SAGVnD,EAAaA,SAAjB,KAIIuD,YAAalN,GACnB,OAAO0B,KAAKgF,OAAO+D,QAAQ,cAAe,CAAEzK,IAAAA,IAGtC8P,qBACNpO,KAAKgF,OAAOuE,SAAS,6BAGfhB,sBACNvI,KAAKgF,OAAO0E,YAAY,6BAGlBrB,uBACN,OAA+B,IAA3BrI,KAAKwG,WAAWxF,OAAqBhB,KAAKwG,WAAW,GAElDxG,KAAKwG,WAAWpF,KAAKmN,MAAMvO,KAAKwG,WAAWxF,OAAS,IAGrD+J,YAAanK,GACnBA,EAAQwK,QAERxK,EAAQ4N,WAAW5N,EAAO,IAGpBoK,wBAAyB3N,EAA8B8L,GAC7DnJ,KAAKgG,wBAAyB,EAE9B,MAAMyI,EAAgBC,SAASC,cAAc,SAC7CvR,EAAYC,EAAMoR,EAAe,CAAElP,UAAU,EAAO2L,UAAU,IAAS,CAAC5M,EAAKL,KAC3E+B,KAAK4O,aAAe3Q,GAGgB,IAAhC+B,KAAKgG,wBAAoC1H,GAC3Cc,QAAQiE,MAAM,mDAAoD/E,GAIpEmQ,EAAcvQ,YAAc8B,KAAKgF,OAAO9G,eAAiBiL,EAAQ,QAI7DvB,sBACN,GAAI5H,KAAK4O,aAAc,CAGrB,GAFA5O,KAAKgG,wBAAyB,EAE1BhG,KAAK4O,aAAarL,QACpB,IACEvD,KAAK4O,aAAarL,UAClB,MAAOjF,GACPc,QAAQC,IAAI,0CAA2Cf,GAG3D0B,KAAK4O,kBAAetP,GAIhB+N,iBACN,MAAMwB,EAAuB,GAE7B,IAAK,MAAMxR,KAAQ2C,KAAKwG,WAAY,CAClC,MAAMsI,EAAiB,CACrB9M,GAAI3E,EAAKyK,WAAW9F,GACpB+M,MAAO/O,KAAKgP,kBAAkB3R,GAC9B4R,OAAQ5R,EAAKyK,WAAW9F,GACxBkN,UAAU,GAGZlP,KAAKgF,OAAOmK,gBAAgBC,gBAAgBN,GAE5CD,EAAqB9M,KAAK,CACxBC,GAAI8M,EAAe9M,GACnB+M,MAAOD,EAAeC,MACtBM,UAAU,IAId,MAAMC,EAA6B,CACjCC,sBAAwBC,GAAWxP,KAAKuP,sBAAsBC,GAC9DC,YAAa,CACXC,MAAOb,IAGX7O,KAAKgF,OAAO2K,MAAK,GAAM5G,QAAQ,oBAAqBuG,GAG9CN,kBAAmB3R,GACzB,IAAI0R,EAAQ1R,EAAKyK,WAAWiH,MAM5B,OAJI1R,EAAKuS,KAAOvS,EAAKuS,KAAO,KAC1Bb,GAAS1R,EAAKuS,KAGTb,EAGDQ,sBAAuBvN,IACjB,IAARA,GAKJhC,KAAKmK,wBACLnK,KAAKkJ,iBAAiBlH,KALgB,IAAhChC,KAAKkG,wBAAiClG,KAAKkK,uBAQ3CpB,gBACN,MAAMG,EAAejJ,KAAK2H,iBAAiBG,WAAW9F,GAChDmN,EAAgBnP,KAAKgF,OAAOmK,gBAOlC,IAAK,IAAI9C,EAAI,EAAGA,EAAI8C,EAAcnO,OAAQqL,IAAK,CACnC8C,EAAc9C,GAClB4C,SAAWhG,IAAckG,EAAcU,eAAiBxD,KAKpEvH,IAAAA,eAAuB,aAAcC,I,4BC9rBrC+K,EAAOC,QAAU,EAAjBD,O,4BCAAA,EAAOC,QAAU,EAAjBD,O,sDCEO,MAAME,EAAO,G","sources":["webpack://peertube-client/./src/assets/player/webtorrent/video-renderer.ts","webpack://peertube-client/./src/assets/player/webtorrent/peertube-chunk-store.ts","webpack://peertube-client/./src/assets/player/webtorrent/webtorrent-plugin.ts","webpack://peertube-client/./src/shims/http.ts","webpack://peertube-client/./src/shims/https.ts","webpack://peertube-client/./src/shims/noop.ts"],"sourcesContent":["// Thanks: https://github.com/feross/render-media\r\n// TODO: use render-media once https://github.com/feross/render-media/issues/32 is fixed\r\n\r\nconst MediaElementWrapper = require('mediasource')\r\nimport { extname } from 'path'\r\nconst videostream = require('videostream')\r\n\r\nconst VIDEOSTREAM_EXTS = [\r\n  '.m4a',\r\n  '.m4v',\r\n  '.mp4'\r\n]\r\n\r\ntype RenderMediaOptions = {\r\n  controls: boolean\r\n  autoplay: boolean\r\n}\r\n\r\nfunction renderVideo (\r\n  file: any,\r\n  elem: HTMLVideoElement,\r\n  opts: RenderMediaOptions,\r\n  callback: (err: Error, renderer: any) => void\r\n) {\r\n  validateFile(file)\r\n\r\n  return renderMedia(file, elem, opts, callback)\r\n}\r\n\r\nfunction renderMedia (file: any, elem: HTMLVideoElement, opts: RenderMediaOptions, callback: (err: Error, renderer?: any) => void) {\r\n  const extension = extname(file.name).toLowerCase()\r\n  let preparedElem: any\r\n  let currentTime = 0\r\n  let renderer: any\r\n\r\n  try {\r\n    if (VIDEOSTREAM_EXTS.indexOf(extension) >= 0) {\r\n      renderer = useVideostream()\r\n    } else {\r\n      renderer = useMediaSource()\r\n    }\r\n  } catch (err) {\r\n    return callback(err)\r\n  }\r\n\r\n  function useVideostream () {\r\n    prepareElem()\r\n\r\n\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      return callback(err)\r\n    })\r\n\r\n\r\n    preparedElem.addEventListener('loadedmetadata', onLoadStart)\r\n    return new videostream(file, preparedElem)\r\n  }\r\n\r\n  function useMediaSource (useVP9 = false) {\r\n    const codecs = getCodec(file.name, useVP9)\r\n\r\n\r\n    prepareElem()\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      // Try with vp9 before returning an error\r\n      if (codecs.indexOf('vp8') !== -1) return fallbackToMediaSource(true)\r\n\r\n      return callback(err)\r\n    })\r\n    preparedElem.addEventListener('loadedmetadata', onLoadStart)\r\n\r\n    const wrapper = new MediaElementWrapper(preparedElem)\r\n    const writable = wrapper.createWriteStream(codecs)\r\n    file.createReadStream().pipe(writable)\r\n\r\n    if (currentTime) preparedElem.currentTime = currentTime\r\n\r\n    return wrapper\r\n  }\r\n\r\n  function fallbackToMediaSource (useVP9 = false) {\r\n    if (useVP9 === true) console.log('Falling back to media source with VP9 enabled.')\r\n    else console.log('Falling back to media source..')\r\n\r\n    useMediaSource(useVP9)\r\n  }\r\n\r\n  function prepareElem () {\r\n    if (preparedElem === undefined) {\r\n      preparedElem = elem\r\n\r\n      preparedElem.addEventListener('progress', function () {\r\n        currentTime = elem.currentTime\r\n      })\r\n    }\r\n  }\r\n\r\n  function onLoadStart () {\r\n    preparedElem.removeEventListener('loadedmetadata', onLoadStart)\r\n\r\n\r\n    if (opts.autoplay) preparedElem.play()\r\n\r\n    callback(null, renderer)\r\n  }\r\n}\r\n\r\nfunction validateFile (file: any) {\r\n  if (file == null) {\r\n    throw new Error('file cannot be null or undefined')\r\n  }\r\n  if (typeof file.name !== 'string') {\r\n    throw new Error('missing or invalid file.name property')\r\n  }\r\n  if (typeof file.createReadStream !== 'function') {\r\n    throw new Error('missing or invalid file.createReadStream property')\r\n  }\r\n}\r\n\r\nfunction getCodec (name: string, useVP9 = false) {\r\n  const ext = extname(name).toLowerCase()\r\n  if (ext === '.mp4') {\r\n    return 'video/mp4; codecs=\"avc1.640029, mp4a.40.5\"'\r\n  }\r\n\r\n  if (ext === '.webm') {\r\n    if (useVP9 === true) return 'video/webm; codecs=\"vp9, opus\"'\r\n\r\n    return 'video/webm; codecs=\"vp8, vorbis\"'\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport {\r\n  renderVideo\r\n}\r\n","// From https://github.com/MinEduTDF/idb-chunk-store\r\n// We use temporary IndexDB (all data are removed on destroy) to avoid RAM issues\r\n// Thanks @santiagogil and @Feross\r\n\r\nimport { EventEmitter } from 'events'\r\nimport Dexie from 'dexie'\r\n\r\nclass ChunkDatabase extends Dexie {\r\n  chunks: Dexie.Table<{ id: number, buf: Buffer }, number>\r\n\r\n  constructor (dbname: string) {\r\n    super(dbname)\r\n\r\n    this.version(1).stores({\r\n      chunks: 'id'\r\n    })\r\n  }\r\n}\r\n\r\nclass ExpirationDatabase extends Dexie {\r\n  databases: Dexie.Table<{ name: string, expiration: number }, number>\r\n\r\n  constructor () {\r\n    super('webtorrent-expiration')\r\n\r\n    this.version(1).stores({\r\n      databases: 'name,expiration'\r\n    })\r\n  }\r\n}\r\n\r\nexport class PeertubeChunkStore extends EventEmitter {\r\n  private static readonly BUFFERING_PUT_MS = 1000\r\n  private static readonly CLEANER_INTERVAL_MS = 1000 * 60 // 1 minute\r\n  private static readonly CLEANER_EXPIRATION_MS = 1000 * 60 * 5 // 5 minutes\r\n\r\n  chunkLength: number\r\n\r\n  private pendingPut: { id: number, buf: Buffer, cb: Function }[] = []\r\n  // If the store is full\r\n  private memoryChunks: { [ id: number ]: Buffer | true } = {}\r\n  private databaseName: string\r\n  private putBulkTimeout: any\r\n  private cleanerInterval: any\r\n  private db: ChunkDatabase\r\n  private expirationDB: ExpirationDatabase\r\n  private readonly length: number\r\n  private readonly lastChunkLength: number\r\n  private readonly lastChunkIndex: number\r\n\r\n  constructor (chunkLength: number, opts: any) {\r\n    super()\r\n\r\n    this.databaseName = 'webtorrent-chunks-'\r\n\r\n    if (!opts) opts = {}\r\n    if (opts.torrent && opts.torrent.infoHash) this.databaseName += opts.torrent.infoHash\r\n    else this.databaseName += '-default'\r\n\r\n    this.setMaxListeners(100)\r\n\r\n    this.chunkLength = Number(chunkLength)\r\n    if (!this.chunkLength) throw new Error('First argument must be a chunk length')\r\n\r\n    this.length = Number(opts.length) || Infinity\r\n\r\n    if (this.length !== Infinity) {\r\n      this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength\r\n      this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1\r\n    }\r\n\r\n    this.db = new ChunkDatabase(this.databaseName)\r\n    // Track databases that expired\r\n    this.expirationDB = new ExpirationDatabase()\r\n\r\n    this.runCleaner()\r\n  }\r\n\r\n  put (index: number, buf: Buffer, cb: (err?: Error) => void) {\r\n    const isLastChunk = (index === this.lastChunkIndex)\r\n    if (isLastChunk && buf.length !== this.lastChunkLength) {\r\n      return this.nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))\r\n    }\r\n    if (!isLastChunk && buf.length !== this.chunkLength) {\r\n      return this.nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))\r\n    }\r\n\r\n    // Specify we have this chunk\r\n    this.memoryChunks[index] = true\r\n\r\n    // Add it to the pending put\r\n    this.pendingPut.push({ id: index, buf, cb })\r\n    // If it's already planned, return\r\n    if (this.putBulkTimeout) return\r\n\r\n    // Plan a future bulk insert\r\n    this.putBulkTimeout = setTimeout(async () => {\r\n      const processing = this.pendingPut\r\n      this.pendingPut = []\r\n      this.putBulkTimeout = undefined\r\n\r\n      try {\r\n        await this.db.transaction('rw', this.db.chunks, () => {\r\n          return this.db.chunks.bulkPut(processing.map(p => ({ id: p.id, buf: p.buf })))\r\n        })\r\n      } catch (err) {\r\n        console.log('Cannot bulk insert chunks. Store them in memory.', { err })\r\n\r\n        processing.forEach(p => this.memoryChunks[ p.id ] = p.buf)\r\n      } finally {\r\n        processing.forEach(p => p.cb())\r\n      }\r\n    }, PeertubeChunkStore.BUFFERING_PUT_MS)\r\n  }\r\n\r\n  get (index: number, opts: any, cb: (err?: Error, buf?: Buffer) => void): void {\r\n    if (typeof opts === 'function') return this.get(index, null, opts)\r\n\r\n    // IndexDB could be slow, use our memory index first\r\n    const memoryChunk = this.memoryChunks[index]\r\n    if (memoryChunk === undefined) {\r\n      const err = new Error('Chunk not found') as any\r\n      err['notFound'] = true\r\n\r\n      return process.nextTick(() => cb(err))\r\n    }\r\n\r\n    // Chunk in memory\r\n    if (memoryChunk !== true) return cb(null, memoryChunk)\r\n\r\n    // Chunk in store\r\n    this.db.transaction('r', this.db.chunks, async () => {\r\n      const result = await this.db.chunks.get({ id: index })\r\n      if (result === undefined) return cb(null, Buffer.alloc(0))\r\n\r\n      const buf = result.buf\r\n      if (!opts) return this.nextTick(cb, null, buf)\r\n\r\n      const offset = opts.offset || 0\r\n      const len = opts.length || (buf.length - offset)\r\n      return cb(null, buf.slice(offset, len + offset))\r\n    })\r\n    .catch(err => {\r\n      console.error(err)\r\n      return cb(err)\r\n    })\r\n  }\r\n\r\n  close (cb: (err?: Error) => void) {\r\n    return this.destroy(cb)\r\n  }\r\n\r\n  async destroy (cb: (err?: Error) => void) {\r\n    try {\r\n      if (this.pendingPut) {\r\n        clearTimeout(this.putBulkTimeout)\r\n        this.pendingPut = null\r\n      }\r\n      if (this.cleanerInterval) {\r\n        clearInterval(this.cleanerInterval)\r\n        this.cleanerInterval = null\r\n      }\r\n\r\n      if (this.db) {\r\n        this.db.close()\r\n\r\n        await this.dropDatabase(this.databaseName)\r\n      }\r\n\r\n      if (this.expirationDB) {\r\n        this.expirationDB.close()\r\n        this.expirationDB = null\r\n      }\r\n\r\n      return cb()\r\n    } catch (err) {\r\n      console.error('Cannot destroy peertube chunk store.', err)\r\n      return cb(err)\r\n    }\r\n  }\r\n\r\n  private runCleaner () {\r\n    this.checkExpiration()\r\n\r\n    this.cleanerInterval = setInterval(async () => {\r\n      this.checkExpiration()\r\n    }, PeertubeChunkStore.CLEANER_INTERVAL_MS)\r\n  }\r\n\r\n  private async checkExpiration () {\r\n    let databasesToDeleteInfo: { name: string }[] = []\r\n\r\n    try {\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, async () => {\r\n        // Update our database expiration since we are alive\r\n        await this.expirationDB.databases.put({\r\n          name: this.databaseName,\r\n          expiration: new Date().getTime() + PeertubeChunkStore.CLEANER_EXPIRATION_MS\r\n        })\r\n\r\n        const now = new Date().getTime()\r\n        databasesToDeleteInfo = await this.expirationDB.databases.where('expiration').below(now).toArray()\r\n      })\r\n    } catch (err) {\r\n      console.error('Cannot update expiration of fetch expired databases.', err)\r\n    }\r\n\r\n    for (const databaseToDeleteInfo of databasesToDeleteInfo) {\r\n      await this.dropDatabase(databaseToDeleteInfo.name)\r\n    }\r\n  }\r\n\r\n  private async dropDatabase (databaseName: string) {\r\n    const dbToDelete = new ChunkDatabase(databaseName)\r\n    console.log('Destroying IndexDB database %s.', databaseName)\r\n\r\n    try {\r\n      await dbToDelete.delete()\r\n\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, () => {\r\n        return this.expirationDB.databases.where({ name: databaseName }).delete()\r\n      })\r\n    } catch (err) {\r\n      console.error('Cannot delete %s.', databaseName, err)\r\n    }\r\n  }\r\n\r\n  private nextTick <T> (cb: (err?: Error, val?: T) => void, err: Error, val?: T) {\r\n    process.nextTick(() => cb(err, val), undefined)\r\n  }\r\n}\r\n","import videojs from 'video.js'\r\nimport * as WebTorrent from 'webtorrent'\r\nimport { renderVideo } from './video-renderer'\r\nimport { LoadedQualityData, PlayerNetworkInfo, WebtorrentPluginOptions } from '../peertube-videojs-typings'\r\nimport { getRtcConfig, timeToInt, videoFileMaxByResolution, videoFileMinByResolution, isIOS, isSafari } from '../utils'\r\nimport { PeertubeChunkStore } from './peertube-chunk-store'\r\nimport {\r\n  getAverageBandwidthInStore,\r\n  getStoredMute,\r\n  getStoredP2PEnabled,\r\n  getStoredVolume,\r\n  saveAverageBandwidth\r\n} from '../peertube-player-local-storage'\r\nimport { VideoFile } from '@shared/models'\r\n\r\nconst CacheChunkStore = require('cache-chunk-store')\r\n\r\ntype PlayOptions = {\r\n  forcePlay?: boolean,\r\n  seek?: number,\r\n  delay?: number\r\n}\r\n\r\nconst Plugin = videojs.getPlugin('plugin')\r\n\r\nclass WebTorrentPlugin extends Plugin {\r\n  readonly videoFiles: VideoFile[]\r\n\r\n  private readonly playerElement: HTMLVideoElement\r\n\r\n  private readonly autoplay: boolean = false\r\n  private readonly startTime: number = 0\r\n  private readonly savePlayerSrcFunction: videojs.Player['src']\r\n  private readonly videoDuration: number\r\n  private readonly CONSTANTS = {\r\n    INFO_SCHEDULER: 1000, // Don't change this\r\n    AUTO_QUALITY_SCHEDULER: 3000, // Check quality every 3 seconds\r\n    AUTO_QUALITY_THRESHOLD_PERCENT: 30, // Bandwidth should be 30% more important than a resolution bitrate to change to it\r\n    AUTO_QUALITY_OBSERVATION_TIME: 10000, // Wait 10 seconds after having change the resolution before another check\r\n    AUTO_QUALITY_HIGHER_RESOLUTION_DELAY: 5000, // Buffering higher resolution during 5 seconds\r\n    BANDWIDTH_AVERAGE_NUMBER_OF_VALUES: 5 // Last 5 seconds to build average bandwidth\r\n  }\r\n\r\n  private readonly webtorrent = new WebTorrent({\r\n    tracker: {\r\n      rtcConfig: getRtcConfig()\r\n    },\r\n    dht: false\r\n  })\r\n\r\n  private currentVideoFile: VideoFile\r\n  private torrent: WebTorrent.Torrent\r\n\r\n  private renderer: any\r\n  private fakeRenderer: any\r\n  private destroyingFakeRenderer = false\r\n\r\n  private autoResolution = true\r\n  private autoResolutionPossible = true\r\n  private isAutoResolutionObservation = false\r\n  private playerRefusedP2P = false\r\n\r\n  private torrentInfoInterval: any\r\n  private autoQualityInterval: any\r\n  private addTorrentDelay: any\r\n  private qualityObservationTimer: any\r\n  private runAutoQualitySchedulerTimer: any\r\n\r\n  private downloadSpeeds: number[] = []\r\n\r\n  constructor (player: videojs.Player, options?: WebtorrentPluginOptions) {\r\n    super(player)\r\n\r\n    this.startTime = timeToInt(options.startTime)\r\n\r\n    // Disable auto play on iOS\r\n    this.autoplay = options.autoplay\r\n    this.playerRefusedP2P = !getStoredP2PEnabled()\r\n\r\n    this.videoFiles = options.videoFiles\r\n    this.videoDuration = options.videoDuration\r\n\r\n    this.savePlayerSrcFunction = this.player.src\r\n    this.playerElement = options.playerElement\r\n\r\n    this.player.ready(() => {\r\n      const playerOptions = this.player.options_\r\n\r\n      /*const volume = getStoredVolume()\r\n      if (volume !== undefined) this.player.volume(volume)\r\n\r\n      const muted = playerOptions.muted !== undefined ? playerOptions.muted : getStoredMute()\r\n      if (muted !== undefined) this.player.muted(muted)*/\r\n\r\n      this.player.duration(options.videoDuration)\r\n\r\n      this.initializePlayer()\r\n      this.runTorrentInfoScheduler()\r\n\r\n      this.player.one('play', () => {\r\n        // Don't run immediately scheduler, wait some seconds the TCP connections are made\r\n        this.runAutoQualitySchedulerTimer = setTimeout(() => this.runAutoQualityScheduler(), this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n      })\r\n    })\r\n  }\r\n\r\n  dispose () {\r\n    clearTimeout(this.addTorrentDelay)\r\n    clearTimeout(this.qualityObservationTimer)\r\n    clearTimeout(this.runAutoQualitySchedulerTimer)\r\n\r\n    clearInterval(this.torrentInfoInterval)\r\n    clearInterval(this.autoQualityInterval)\r\n\r\n    // Don't need to destroy renderer, video player will be destroyed\r\n    this.flushVideoFile(this.currentVideoFile, false)\r\n\r\n    this.destroyFakeRenderer()\r\n  }\r\n\r\n  getCurrentResolutionId () {\r\n    return this.currentVideoFile ? this.currentVideoFile.resolution.id : -1\r\n  }\r\n\r\n  updateVideoFile (\r\n    videoFile?: VideoFile,\r\n    options: {\r\n      forcePlay?: boolean,\r\n      seek?: number,\r\n      delay?: number\r\n    } = {},\r\n    done: () => void = () => { /* empty */ }\r\n  ) {\r\n    // Automatically choose the adapted video file\r\n    if (!videoFile) {\r\n      const savedAverageBandwidth = getAverageBandwidthInStore()\r\n      videoFile = savedAverageBandwidth\r\n        ? this.getAppropriateFile(savedAverageBandwidth)\r\n        : this.pickAverageVideoFile()\r\n    }\r\n\r\n    if (!videoFile) {\r\n      \r\n      throw Error(`Can't update video file since videoFile is undefined.`)\r\n\r\n      /*\r\n\r\n      const error: { message: string, code?: number } = {\r\n        message: \"Can't update video file since videoFile is undefined.\"\r\n      }\r\n\r\n      this.player.tech(true).error = () => error as any\r\n      this.player.tech(true).trigger('error')\r\n\r\n      return\r\n\r\n\r\n      */\r\n    }\r\n\r\n    // Don't add the same video file once again\r\n    if (this.currentVideoFile !== undefined && this.currentVideoFile.magnetUri === videoFile.magnetUri) {\r\n      return\r\n    }\r\n\r\n    // Do not display error to user because we will have multiple fallback\r\n    this.disableErrorDisplay();\r\n\r\n    // Hack to \"simulate\" src link in video.js >= 6\r\n    // Without this, we can't play the video after pausing it\r\n    // https://github.com/videojs/video.js/blob/master/src/js/player.js#L1633\r\n    (this.player as any).src = () => true\r\n    const oldPlaybackRate = this.player.playbackRate()\r\n\r\n    const previousVideoFile = this.currentVideoFile\r\n    this.currentVideoFile = videoFile\r\n\r\n    // Don't try on iOS that does not support MediaSource\r\n    // Or don't use P2P if webtorrent is disabled\r\n    if (isIOS() || this.playerRefusedP2P) {\r\n      return this.fallbackToHttp(options, () => {\r\n        this.player.playbackRate(oldPlaybackRate)\r\n        return done()\r\n      })\r\n    }\r\n\r\n\r\n    this.addTorrent(this.currentVideoFile.magnetUri, previousVideoFile, options, () => {\r\n      this.player.playbackRate(oldPlaybackRate)\r\n      return done()\r\n    })\r\n\r\n    this.changeQuality()\r\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.currentVideoFile.resolution.id })\r\n  }\r\n\r\n  updateResolution (resolutionId: number, delay = 0) {\r\n    // Remember player state\r\n    const currentTime = this.player.currentTime()\r\n    const isPaused = this.player.paused()\r\n\r\n    // Hide bigPlayButton\r\n    if (!isPaused) {\r\n      this.player.bigPlayButton.hide()\r\n    }\r\n\r\n    // Audio-only (resolutionId === 0) gets special treatment\r\n    if (resolutionId === 0) {\r\n      // Audio-only: show poster, do not auto-hide controls\r\n      this.player.addClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.show()\r\n    } else {\r\n      // Hide poster to have black background\r\n      this.player.removeClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.hide()\r\n    }\r\n\r\n    const newVideoFile = this.videoFiles.find(f => f.resolution.id === resolutionId)\r\n    const options = {\r\n      forcePlay: false,\r\n      delay,\r\n      seek: currentTime + (delay / 1000)\r\n    }\r\n\r\n    this.updateVideoFile(newVideoFile, options)\r\n  }\r\n\r\n  flushVideoFile (videoFile: VideoFile, destroyRenderer = true) {\r\n    if (videoFile !== undefined && this.webtorrent.get(videoFile.magnetUri)) {\r\n      if (destroyRenderer === true && this.renderer && this.renderer.destroy) this.renderer.destroy()\r\n\r\n      this.webtorrent.remove(videoFile.magnetUri)\r\n    }\r\n  }\r\n\r\n  enableAutoResolution () {\r\n    this.autoResolution = true\r\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.getCurrentResolutionId() })\r\n  }\r\n\r\n  disableAutoResolution (forbid = false) {\r\n    if (forbid === true) this.autoResolutionPossible = false\r\n\r\n    this.autoResolution = false\r\n    this.trigger('autoResolutionChange', { possible: this.autoResolutionPossible })\r\n    this.trigger('resolutionChange', { auto: this.autoResolution, resolutionId: this.getCurrentResolutionId() })\r\n  }\r\n\r\n  isAutoResolutionPossible () {\r\n    return this.autoResolutionPossible\r\n  }\r\n\r\n  getTorrent () {\r\n    return this.torrent\r\n  }\r\n\r\n  getCurrentVideoFile () {\r\n    return this.currentVideoFile\r\n  }\r\n\r\n  private addTorrent (\r\n    magnetOrTorrentUrl: string,\r\n    previousVideoFile: VideoFile,\r\n    options: PlayOptions,\r\n    done: Function\r\n  ) {\r\n    if (!magnetOrTorrentUrl) return this.fallbackToHttp(options, done)\r\n\r\n    const oldTorrent = this.torrent\r\n    const torrentOptions = {\r\n      // Don't use arrow function: it breaks webtorrent (that uses `new` keyword)\r\n      store: function (chunkLength: number, storeOpts: any) {\r\n        return new CacheChunkStore(new PeertubeChunkStore(chunkLength, storeOpts), {\r\n          max: 100\r\n        })\r\n      }\r\n    }\r\n\r\n    this.torrent = this.webtorrent.add(magnetOrTorrentUrl, torrentOptions, torrent => {\r\n      if (oldTorrent) {\r\n        // Pause the old torrent\r\n        this.stopTorrent(oldTorrent)\r\n\r\n        // We use a fake renderer so we download correct pieces of the next file\r\n        if(options.delay) \r\n          this.renderFileInFakeElement(torrent.files[ 0 ], options.delay)\r\n      }\r\n\r\n      // Render the video in a few seconds? (on resolution change for example, we wait some seconds of the new video resolution)\r\n      this.addTorrentDelay = setTimeout(() => {\r\n\r\n        // We don't need the fake renderer anymore\r\n        this.destroyFakeRenderer()\r\n\r\n        const paused = this.player.paused()\r\n\r\n        this.flushVideoFile(previousVideoFile)\r\n\r\n        // Update progress bar (just for the UI), do not wait rendering\r\n        if (options.seek) this.player.currentTime(options.seek)\r\n\r\n        const renderVideoOptions = { autoplay: false, controls: true }\r\n        renderVideo(torrent.files[ 0 ], this.playerElement, renderVideoOptions, (err, renderer) => {\r\n          this.renderer = renderer\r\n\r\n          if (err) return this.fallbackToHttp(options, done)\r\n\r\n          //this.playerElement.play()\r\n\r\n          setTimeout(() => {\r\n            return this.tryToPlay(err => {\r\n\r\n              if (err) return done(err)\r\n  \r\n              if (options.seek) this.seek(options.seek)\r\n              if (options.forcePlay === false && paused === true) this.player.pause()\r\n  \r\n              return done()\r\n            })\r\n          }, 10)\r\n         \r\n        })\r\n      }, options.delay || 0)\r\n    })\r\n\r\n    this.torrent.on('error', (err: any) => console.error(err))\r\n\r\n    this.torrent.on('warning', (err: any) => {\r\n\r\n      //// TEMP, TO DO\r\n\r\n      /*if (err.message.indexOf('Error connecting to wss') !== -1 || err.message.indexOf('Unsupported tracker protocol') !== -1) {\r\n        this.fallbackToHttp(options, done)\r\n        return\r\n      }*/\r\n\r\n      // We don't support HTTP tracker but we don't care -> we use the web socket tracker\r\n      if (err.message.indexOf('Unsupported tracker protocol') !== -1) return\r\n\r\n      // Users don't care about issues with WebRTC, but developers do so log it in the console\r\n      if (err.message.indexOf('Ice connection failed') !== -1) {\r\n        console.log(err)\r\n        return\r\n      }\r\n\r\n      // Magnet hash is not up to date with the torrent file, add directly the torrent file\r\n      if (err.message.indexOf('incorrect info hash') !== -1) {\r\n        console.error('Incorrect info hash detected, falling back to torrent file.')\r\n        const newOptions = { forcePlay: true, seek: options.seek }\r\n        return this.addTorrent(this.torrent[ 'xs' ], previousVideoFile, newOptions, done)\r\n      }\r\n\r\n      // Remote instance is down\r\n      if (err.message.indexOf('from xs param') !== -1) {\r\n        this.handleError(err)\r\n      }\r\n\r\n    })\r\n  }\r\n\r\n  private tryToPlay (done?: (err?: Error) => void) {\r\n\r\n    if (!done) done = function () {}\r\n\r\n    const playPromise = this.player.play()\r\n\r\n    if (playPromise !== undefined) {\r\n\r\n      return playPromise.then(() => done()).catch((err: Error) => {\r\n          if (err.message.indexOf('The play() request') !== -1) {\r\n            return\r\n          }\r\n\r\n          console.log(\"PAUSE\")\r\n          this.player.pause()\r\n          this.player.posterImage.show()\r\n          this.player.removeClass('vjs-has-autoplay')\r\n          this.player.removeClass('vjs-has-big-play-button-clicked')\r\n          this.player.removeClass('vjs-playing-audio-only-content')\r\n\r\n          return done()\r\n        })\r\n    }\r\n\r\n    return done()\r\n\r\n    \r\n  }\r\n\r\n  private seek (time: number) {\r\n    this.player.currentTime(time)\r\n    this.player.handleTechSeeked_()\r\n  }\r\n\r\n  private getAppropriateFile (averageDownloadSpeed?: number): VideoFile {\r\n    if (this.videoFiles === undefined) return undefined\r\n\r\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\r\n\r\n    if (files.length === 0) return undefined\r\n    if (files.length === 1) return files[0]\r\n\r\n    // Don't change the torrent if the player ended\r\n    if (this.torrent && this.torrent.progress === 1 && this.player.ended()) return this.currentVideoFile\r\n\r\n    if (!averageDownloadSpeed) averageDownloadSpeed = this.getAndSaveActualDownloadSpeed()\r\n\r\n    // Limit resolution according to player height\r\n    const playerHeight = this.playerElement.offsetHeight\r\n\r\n    // We take the first resolution just above the player height\r\n    // Example: player height is 530px, we want the 720p file instead of 480p\r\n    let maxResolution = files[0].resolution.id\r\n    for (let i = files.length - 1; i >= 0; i--) {\r\n      const resolutionId = files[i].resolution.id\r\n      if (resolutionId !== 0 && resolutionId >= playerHeight) {\r\n        maxResolution = resolutionId\r\n        break\r\n      }\r\n    }\r\n\r\n    // Filter videos we can play according to our screen resolution and bandwidth\r\n    const filteredFiles = files.filter(f => f.resolution.id <= maxResolution)\r\n                               .filter(f => {\r\n                                 const fileBitrate = (f.size / this.videoDuration)\r\n                                 let threshold = fileBitrate\r\n\r\n                                 // If this is for a higher resolution or an initial load: add a margin\r\n                                 if (!this.currentVideoFile || f.resolution.id > this.currentVideoFile.resolution.id) {\r\n                                   threshold += ((fileBitrate * this.CONSTANTS.AUTO_QUALITY_THRESHOLD_PERCENT) / 100)\r\n                                 }\r\n\r\n                                 return averageDownloadSpeed > threshold\r\n                               })\r\n\r\n    // If the download speed is too bad, return the lowest resolution we have\r\n    if (filteredFiles.length === 0) return videoFileMinByResolution(files)\r\n\r\n    return videoFileMaxByResolution(filteredFiles)\r\n  }\r\n\r\n  private getAndSaveActualDownloadSpeed () {\r\n    const start = Math.max(this.downloadSpeeds.length - this.CONSTANTS.BANDWIDTH_AVERAGE_NUMBER_OF_VALUES, 0)\r\n    const lastDownloadSpeeds = this.downloadSpeeds.slice(start, this.downloadSpeeds.length)\r\n    if (lastDownloadSpeeds.length === 0) return -1\r\n\r\n    const sum = lastDownloadSpeeds.reduce((a, b) => a + b)\r\n    const averageBandwidth = Math.round(sum / lastDownloadSpeeds.length)\r\n\r\n    // Save the average bandwidth for future use\r\n    saveAverageBandwidth(averageBandwidth)\r\n\r\n    return averageBandwidth\r\n  }\r\n\r\n  private initializePlayer () {\r\n    this.buildQualities()\r\n\r\n    if (this.autoplay) {\r\n      this.player.posterImage.hide()\r\n\r\n      return this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n\r\n    // Proxy first play\r\n    const oldPlay = this.player.play.bind(this.player);\r\n    (this.player as any).play = () => {\r\n      this.player.addClass('vjs-has-big-play-button-clicked')\r\n      this.player.play = oldPlay\r\n\r\n      this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n  }\r\n\r\n  private runAutoQualityScheduler () {\r\n    this.autoQualityInterval = setInterval(() => {\r\n\r\n      // Not initialized or in HTTP fallback\r\n      if (this.torrent === undefined || this.torrent === null) return\r\n      if (this.autoResolution === false) return\r\n      if (this.isAutoResolutionObservation === true) return\r\n\r\n      const file = this.getAppropriateFile()\r\n      let changeResolution = false\r\n      let changeResolutionDelay = 0\r\n\r\n      // Lower resolution\r\n      if (this.isPlayerWaiting() && file.resolution.id < this.currentVideoFile.resolution.id) {\r\n        changeResolution = true\r\n      } else if (file.resolution.id > this.currentVideoFile.resolution.id) { // Higher resolution\r\n        changeResolution = true\r\n        changeResolutionDelay = this.CONSTANTS.AUTO_QUALITY_HIGHER_RESOLUTION_DELAY\r\n      }\r\n\r\n      if (changeResolution === true) {\r\n        this.updateResolution(file.resolution.id, changeResolutionDelay)\r\n\r\n        // Wait some seconds in observation of our new resolution\r\n        this.isAutoResolutionObservation = true\r\n\r\n        this.qualityObservationTimer = setTimeout(() => {\r\n          this.isAutoResolutionObservation = false\r\n        }, this.CONSTANTS.AUTO_QUALITY_OBSERVATION_TIME)\r\n      }\r\n    }, this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n  }\r\n\r\n  private isPlayerWaiting () {\r\n    return this.player && this.player.hasClass('vjs-waiting')\r\n  }\r\n\r\n  private runTorrentInfoScheduler () {\r\n    this.torrentInfoInterval = setInterval(() => {\r\n      \r\n\r\n      // Not initialized yet\r\n      if (this.torrent === undefined) return\r\n\r\n      // Http fallback\r\n      if (this.torrent === null) return this.player.trigger('p2pInfo', false)\r\n\r\n      // this.webtorrent.downloadSpeed because we need to take into account the potential old torrent too\r\n      if (this.webtorrent.downloadSpeed !== 0) this.downloadSpeeds.push(this.webtorrent.downloadSpeed)\r\n\r\n    \r\n\r\n      return this.player.trigger('p2pInfo', {\r\n        source: 'webtorrent',\r\n        http: {\r\n          downloadSpeed: 0,\r\n          uploadSpeed: 0,\r\n          downloaded: 0,\r\n          uploaded: 0\r\n        },\r\n        p2p: {\r\n          downloadSpeed: this.torrent.downloadSpeed,\r\n          numPeers: this.torrent.numPeers,\r\n          uploadSpeed: this.torrent.uploadSpeed,\r\n          downloaded: this.torrent.downloaded,\r\n          uploaded: this.torrent.uploaded\r\n        }\r\n      } as PlayerNetworkInfo)\r\n    }, this.CONSTANTS.INFO_SCHEDULER)\r\n  }\r\n\r\n  private fallbackToHttp (options: PlayOptions, done?: Function) {\r\n\r\n\r\n    const paused = this.player.paused()\r\n\r\n    this.disableAutoResolution(true)\r\n\r\n    this.flushVideoFile(this.currentVideoFile, true)\r\n    this.torrent = null\r\n\r\n    // Enable error display now this is our last fallback\r\n    this.player.one('error', () => this.enableErrorDisplay())\r\n\r\n    const httpUrl = this.currentVideoFile.fileUrl\r\n    this.player.src = this.savePlayerSrcFunction\r\n    this.player.src(httpUrl)\r\n\r\n    this.changeQuality()\r\n\r\n    // We changed the source, so reinit captions\r\n    this.player.trigger('sourcechange')\r\n\r\n    return this.tryToPlay(err => {\r\n\r\n      if (err && done) return done(err)\r\n\r\n      if (options.seek) this.seek(options.seek)\r\n      if (options.forcePlay === false && paused === true) {\r\n        console.log(\"PLAUSE\")\r\n        this.player.pause()\r\n      }\r\n\r\n      if (done) return done()\r\n    })\r\n  }\r\n\r\n  private handleError (err: Error | string) {\r\n    return this.player.trigger('customError', { err })\r\n  }\r\n\r\n  private enableErrorDisplay () {\r\n    this.player.addClass('vjs-error-display-enabled')\r\n  }\r\n\r\n  private disableErrorDisplay () {\r\n    this.player.removeClass('vjs-error-display-enabled')\r\n  }\r\n\r\n  private pickAverageVideoFile () {\r\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\r\n\r\n    return this.videoFiles[Math.floor(this.videoFiles.length / 2)]\r\n  }\r\n\r\n  private stopTorrent (torrent: WebTorrent.Torrent) {\r\n    torrent.pause()\r\n    // Pause does not remove actual peers (in particular the webseed peer)\r\n    torrent.removePeer(torrent[ 'ws' ])\r\n  }\r\n\r\n  private renderFileInFakeElement (file: WebTorrent.TorrentFile, delay: number) {\r\n    this.destroyingFakeRenderer = false\r\n\r\n    const fakeVideoElem = document.createElement('video')\r\n    renderVideo(file, fakeVideoElem, { autoplay: false, controls: false }, (err, renderer) => {\r\n      this.fakeRenderer = renderer\r\n\r\n      // The renderer returns an error when we destroy it, so skip them\r\n      if (this.destroyingFakeRenderer === false && err) {\r\n        console.error('Cannot render new torrent in fake video element.', err)\r\n      }\r\n\r\n      // Load the future file at the correct time (in delay MS - 2 seconds)\r\n      fakeVideoElem.currentTime = this.player.currentTime() + (delay - 2000)\r\n    })\r\n  }\r\n\r\n  private destroyFakeRenderer () {\r\n    if (this.fakeRenderer) {\r\n      this.destroyingFakeRenderer = true\r\n\r\n      if (this.fakeRenderer.destroy) {\r\n        try {\r\n          this.fakeRenderer.destroy()\r\n        } catch (err) {\r\n          console.log('Cannot destroy correctly fake renderer.', err)\r\n        }\r\n      }\r\n      this.fakeRenderer = undefined\r\n    }\r\n  }\r\n\r\n  private buildQualities () {\r\n    const qualityLevelsPayload = []\r\n\r\n    for (const file of this.videoFiles) {\r\n      const representation = {\r\n        id: file.resolution.id,\r\n        label: this.buildQualityLabel(file),\r\n        height: file.resolution.id,\r\n        _enabled: true\r\n      }\r\n\r\n      this.player.qualityLevels().addQualityLevel(representation)\r\n\r\n      qualityLevelsPayload.push({\r\n        id: representation.id,\r\n        label: representation.label,\r\n        selected: false\r\n      })\r\n    }\r\n\r\n    const payload: LoadedQualityData = {\r\n      qualitySwitchCallback: (d: any) => this.qualitySwitchCallback(d),\r\n      qualityData: {\r\n        video: qualityLevelsPayload\r\n      }\r\n    }\r\n    this.player.tech(true).trigger('loadedqualitydata', payload)\r\n  }\r\n\r\n  private buildQualityLabel (file: VideoFile) {\r\n    let label = file.resolution.label\r\n\r\n    if (file.fps && file.fps >= 50) {\r\n      label += file.fps\r\n    }\r\n\r\n    return label\r\n  }\r\n\r\n  private qualitySwitchCallback (id: number) {\r\n    if (id === -1) {\r\n      if (this.autoResolutionPossible === true) this.enableAutoResolution()\r\n      return\r\n    }\r\n\r\n    this.disableAutoResolution()\r\n    this.updateResolution(id)\r\n  }\r\n\r\n  private changeQuality () {\r\n    const resolutionId = this.currentVideoFile.resolution.id\r\n    const qualityLevels = this.player.qualityLevels()\r\n\r\n    /*if (resolutionId === -1) {\r\n      qualityLevels.selectedIndex = -1\r\n      return\r\n    }*/\r\n\r\n    for (let i = 0; i < qualityLevels.length; i++) {\r\n      const q = qualityLevels[i]\r\n      if (q.height === resolutionId) qualityLevels.selectedIndex_ = i\r\n    }\r\n  }\r\n}\r\n\r\nvideojs.registerPlugin('webtorrent', WebTorrentPlugin)\r\nexport { WebTorrentPlugin }\r\n","module.exports = require('stream-http')\r\n","module.exports = require('https-browserify')\r\n","// Does nothing. Used to shim out node.js modules\r\n// which are no-ops in the browser.\r\nexport const NOOP = 0\r\n"],"names":["MediaElementWrapper","require","videostream","VIDEOSTREAM_EXTS","renderVideo","file","elem","opts","callback","Error","name","createReadStream","validateFile","extension","extname","toLowerCase","preparedElem","renderer","currentTime","indexOf","useVideostream","useMediaSource","err","prepareElem","addEventListener","onError","removeEventListener","onLoadStart","useVP9","codecs","getCodec","fallbackToMediaSource","wrapper","writable","createWriteStream","pipe","console","log","undefined","autoplay","play","renderMedia","ext","ChunkDatabase","Dexie","constructor","dbname","super","this","version","stores","chunks","ExpirationDatabase","databases","PeertubeChunkStore","EventEmitter","chunkLength","pendingPut","memoryChunks","databaseName","torrent","infoHash","setMaxListeners","Number","length","Infinity","lastChunkLength","lastChunkIndex","Math","ceil","db","expirationDB","runCleaner","put","index","buf","cb","isLastChunk","nextTick","push","id","putBulkTimeout","setTimeout","__awaiter","processing","transaction","bulkPut","map","p","forEach","BUFFERING_PUT_MS","get","memoryChunk","process","result","Buffer","alloc","offset","len","slice","catch","error","close","destroy","clearTimeout","cleanerInterval","clearInterval","dropDatabase","checkExpiration","setInterval","CLEANER_INTERVAL_MS","databasesToDeleteInfo","expiration","Date","getTime","CLEANER_EXPIRATION_MS","now","where","below","toArray","databaseToDeleteInfo","dbToDelete","delete","val","CacheChunkStore","Plugin","videojs","WebTorrentPlugin","player","options","startTime","CONSTANTS","INFO_SCHEDULER","AUTO_QUALITY_SCHEDULER","AUTO_QUALITY_THRESHOLD_PERCENT","AUTO_QUALITY_OBSERVATION_TIME","AUTO_QUALITY_HIGHER_RESOLUTION_DELAY","BANDWIDTH_AVERAGE_NUMBER_OF_VALUES","webtorrent","WebTorrent","tracker","rtcConfig","getRtcConfig","dht","destroyingFakeRenderer","autoResolution","autoResolutionPossible","isAutoResolutionObservation","playerRefusedP2P","downloadSpeeds","timeToInt","getStoredP2PEnabled","videoFiles","videoDuration","savePlayerSrcFunction","src","playerElement","ready","options_","duration","initializePlayer","runTorrentInfoScheduler","one","runAutoQualitySchedulerTimer","runAutoQualityScheduler","dispose","addTorrentDelay","qualityObservationTimer","torrentInfoInterval","autoQualityInterval","flushVideoFile","currentVideoFile","destroyFakeRenderer","getCurrentResolutionId","resolution","updateVideoFile","videoFile","done","savedAverageBandwidth","getAverageBandwidthInStore","getAppropriateFile","pickAverageVideoFile","magnetUri","disableErrorDisplay","oldPlaybackRate","playbackRate","previousVideoFile","isIOS","fallbackToHttp","addTorrent","changeQuality","trigger","auto","resolutionId","updateResolution","delay","paused","bigPlayButton","hide","addClass","posterImage","show","removeClass","newVideoFile","find","f","forcePlay","seek","destroyRenderer","remove","enableAutoResolution","disableAutoResolution","possible","isAutoResolutionPossible","getTorrent","getCurrentVideoFile","magnetOrTorrentUrl","oldTorrent","torrentOptions","store","storeOpts","max","add","stopTorrent","renderFileInFakeElement","files","controls","tryToPlay","pause","on","message","newOptions","handleError","playPromise","then","time","handleTechSeeked_","averageDownloadSpeed","filter","progress","ended","getAndSaveActualDownloadSpeed","playerHeight","offsetHeight","maxResolution","i","filteredFiles","fileBitrate","size","threshold","videoFileMinByResolution","videoFileMaxByResolution","start","lastDownloadSpeeds","sum","reduce","a","b","averageBandwidth","round","saveAverageBandwidth","buildQualities","oldPlay","bind","changeResolution","changeResolutionDelay","isPlayerWaiting","hasClass","downloadSpeed","source","http","uploadSpeed","downloaded","uploaded","p2p","numPeers","enableErrorDisplay","httpUrl","fileUrl","floor","removePeer","fakeVideoElem","document","createElement","fakeRenderer","qualityLevelsPayload","representation","label","buildQualityLabel","height","_enabled","qualityLevels","addQualityLevel","selected","payload","qualitySwitchCallback","d","qualityData","video","tech","fps","selectedIndex_","module","exports","NOOP"],"sourceRoot":""}